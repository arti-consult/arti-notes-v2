{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 252, "column": 0}, "map": {"version":3,"sources":["file://E%3A/breyholtz%20holding/arti-notes/arti-notes-v2/src/utils/supabase/client.ts"],"sourcesContent":["import { createBrowserClient } from '@supabase/ssr'\r\n\r\nexport function createClient() {\r\n  return createBrowserClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\r\n  )\r\n}"],"names":[],"mappings":";;;AAAA;AAAA;;AAEO,SAAS;IACd,OAAO,CAAA,GAAA,4KAAA,CAAA,sBAAmB,AAAD;AAI3B","debugId":null}},
    {"offset": {"line": 267, "column": 0}, "map": {"version":3,"sources":["file://E%3A/breyholtz%20holding/arti-notes/arti-notes-v2/src/utils/supabase/server.ts"],"sourcesContent":["import { createServerClient } from \"@supabase/ssr\";\r\nimport { cookies } from \"next/headers\";\r\n\r\nexport async function createClient() {\r\n  const cookieStore = await cookies();\r\n\r\n  return createServerClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n    {\r\n      cookies: {\r\n        get(name: string) {\r\n          return cookieStore.get(name)?.value;\r\n        },\r\n        set(name: string, value: string, options: any) {\r\n          cookieStore.set({ name, value, ...options });\r\n        },\r\n        remove(name: string, options: any) {\r\n          cookieStore.set({ name, value: \"\", ...options });\r\n        },\r\n      },\r\n    }\r\n  );\r\n}\r\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;;;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,CAAA,GAAA,iIAAA,CAAA,UAAO,AAAD;IAEhC,OAAO,CAAA,GAAA,2KAAA,CAAA,qBAAkB,AAAD,sUAGtB;QACE,SAAS;YACP,KAAI,IAAY;gBACd,OAAO,YAAY,GAAG,CAAC,OAAO;YAChC;YACA,KAAI,IAAY,EAAE,KAAa,EAAE,OAAY;gBAC3C,YAAY,GAAG,CAAC;oBAAE;oBAAM;oBAAO,GAAG,OAAO;gBAAC;YAC5C;YACA,QAAO,IAAY,EAAE,OAAY;gBAC/B,YAAY,GAAG,CAAC;oBAAE;oBAAM,OAAO;oBAAI,GAAG,OAAO;gBAAC;YAChD;QACF;IACF;AAEJ","debugId":null}},
    {"offset": {"line": 305, "column": 0}, "map": {"version":3,"sources":["file://E%3A/breyholtz%20holding/arti-notes/arti-notes-v2/src/utils/calendar/google-calendar.ts"],"sourcesContent":["// src/utils/calendar/google-calendar.ts\nimport { google } from 'googleapis';\nimport { createClient as createClientClient } from '@/utils/supabase/client';\nimport { createClient as createClientServer } from '@/utils/supabase/server';\n\n// Google OAuth scopes needed\nconst SCOPES = [\n  'https://www.googleapis.com/auth/calendar.readonly',\n  'https://www.googleapis.com/auth/calendar.events.readonly'\n];\n\n// Google Calendar API credentials\nconst credentials = {\n  client_id: process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID as string,\n  client_secret: process.env.GOOGLE_CLIENT_SECRET as string,\n  redirect_uri: `${process.env.NEXT_PUBLIC_APP_URL}/api/auth/google/callback`\n};\n\n// Debug log the credentials and environment\nconsole.log('Environment check:', {\n  NODE_ENV: process.env.NODE_ENV,\n  APP_URL: process.env.NEXT_PUBLIC_APP_URL,\n  hasClientId: !!process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID,\n  hasClientSecret: !!process.env.GOOGLE_CLIENT_SECRET\n});\n\nconsole.log('Google OAuth Configuration:', {\n  redirectUri: credentials.redirect_uri,\n  hasClientId: !!credentials.client_id,\n  hasClientSecret: !!credentials.client_secret,\n  scopes: SCOPES\n});\n\n/**\n * Create OAuth2 client for Google API\n */\nexport function createOAuth2Client() {\n  const client = new google.auth.OAuth2(\n    credentials.client_id,\n    credentials.client_secret,\n    credentials.redirect_uri\n  );\n  \n  console.log('Created OAuth2 client with redirect URI:', credentials.redirect_uri);\n  \n  return client;\n}\n\n/**\n * Generate Google OAuth URL for user authorization\n */\nexport function getGoogleAuthUrl(): string {\n  console.log('Generating Google OAuth URL...');\n  const oauth2Client = createOAuth2Client();\n  \n  const url = oauth2Client.generateAuthUrl({\n    access_type: 'offline',\n    scope: SCOPES,\n    prompt: 'consent', // Force to get refresh token\n    include_granted_scopes: true\n  });\n  \n  console.log('Generated OAuth URL:', url);\n  return url;\n}\n\n/**\n * Exchange authorization code for tokens and save to Supabase\n */\nexport async function handleGoogleCallback(code: string): Promise<boolean> {\n  try {\n    const supabase = await createClientServer();\n    const oauth2Client = createOAuth2Client();\n    \n    // Exchange code for tokens\n    const { tokens } = await oauth2Client.getToken(code);\n    \n    // Get current user\n    const { data: { user }, error: userError } = await supabase.auth.getUser();\n    \n    if (userError || !user) {\n      console.error('User not authenticated');\n      return false;\n    }\n    \n    console.log('Saving Google Calendar connection...');\n    \n    // Store tokens in Supabase calendar_connections table\n    const { error } = await supabase\n      .from('calendar_connections')\n      .upsert({\n        user_id: user.id,\n        provider: 'google',\n        access_token: tokens.access_token,\n        refresh_token: tokens.refresh_token,\n        token_expiry: tokens.expiry_date ? new Date(tokens.expiry_date).toISOString() : null,\n        scope: SCOPES.join(' '),\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      }, {\n        onConflict: 'user_id,provider'\n      });\n      \n    if (error) {\n      console.error('Error storing tokens:', error);\n      return false;\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error handling Google callback:', error);\n    return false;\n  }\n}\n\n/**\n * Refresh tokens if needed\n */\nexport async function refreshTokenIfNeeded(userId: string): Promise<boolean> {\n  try {\n    const supabase = createClientClient();\n    \n    // Get stored tokens from calendar_connections\n    const { data, error } = await supabase\n      .from('calendar_connections')\n      .select('*')\n      .eq('user_id', userId)\n      .eq('provider', 'google')\n      .single();\n      \n    if (error || !data) {\n      console.error('No Google Calendar connection found');\n      return false;\n    }\n    \n    // Check if token is expired\n    const tokenExpiry = new Date(data.token_expiry);\n    const now = new Date();\n    \n    if (tokenExpiry <= now && data.refresh_token) {\n      console.log('Refreshing expired token...');\n      \n      // Token is expired, refresh it\n      const oauth2Client = createOAuth2Client();\n      oauth2Client.setCredentials({\n        refresh_token: data.refresh_token\n      });\n      \n      const response = await oauth2Client.getAccessToken();\n      const token = response.token;\n      const expiryDate = oauth2Client.credentials.expiry_date;\n      \n      // Update tokens in database\n      const { error: updateError } = await supabase\n        .from('calendar_connections')\n        .update({\n          access_token: token,\n          token_expiry: expiryDate ? new Date(expiryDate).toISOString() : null,\n          updated_at: new Date().toISOString()\n        })\n        .eq('user_id', userId)\n        .eq('provider', 'google');\n        \n      if (updateError) {\n        console.error('Error updating tokens:', updateError);\n        return false;\n      }\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error refreshing token:', error);\n    return false;\n  }\n}\n\ninterface CalendarEvent {\n  id: string;\n  calendar_id: string;\n  title: string;\n  description: string | null;\n  start_time: string;\n  end_time: string;\n  location: string | null;\n  meeting_link: string | null;\n  attendees: { email: string; name?: string }[];\n  is_organizer: boolean;\n  status: 'confirmed' | 'tentative' | 'cancelled';\n  html_link: string;\n  created_at: string;\n  updated_at: string;\n}\n\n/**\n * Fetch upcoming calendar events from Google Calendar\n */\nexport async function fetchUpcomingGoogleEvents(userId: string, daysAhead = 30): Promise<CalendarEvent[]> {\n  try {\n    const supabase = createClientClient();\n    \n    // Get stored tokens\n    const { data: connectionData, error: connectionError } = await supabase\n      .from('calendar_connections')\n      .select('*')\n      .eq('user_id', userId)\n      .eq('provider', 'google')\n      .single();\n      \n    if (connectionError || !connectionData) {\n      console.error('No Google Calendar connection found');\n      return [];\n    }\n    \n    // Refresh token if needed\n    await refreshTokenIfNeeded(userId);\n    \n    // Setup OAuth client with token\n    const oauth2Client = createOAuth2Client();\n    oauth2Client.setCredentials({\n      access_token: connectionData.access_token,\n      refresh_token: connectionData.refresh_token\n    });\n    \n    const calendar = google.calendar({ version: 'v3', auth: oauth2Client });\n    \n    // Calculate time range\n    const now = new Date();\n    const timeMin = now.toISOString();\n    const future = new Date();\n    future.setDate(future.getDate() + daysAhead);\n    const timeMax = future.toISOString();\n    \n    // Fetch calendar list first\n    const { data: { items: calendarList } } = await calendar.calendarList.list();\n    \n    if (!calendarList || calendarList.length === 0) {\n      return [];\n    }\n    \n    // Fetch events from each calendar\n    const allEvents: CalendarEvent[] = [];\n    \n    for (const cal of calendarList) {\n      if (!cal.id) continue;\n      \n      const { data } = await calendar.events.list({\n        calendarId: cal.id,\n        timeMin,\n        timeMax,\n        singleEvents: true,\n        orderBy: 'startTime',\n        maxResults: 100\n      });\n      \n      if (!data.items || data.items.length === 0) continue;\n      \n      // Transform events to our format\n      for (const event of data.items) {\n        if (!event.id || !event.summary) continue;\n        \n        // Skip events without start/end times\n        if (!event.start || !event.end) continue;\n        \n        // Get meeting links from conference data or description\n        let meetingLink: string | null = null;\n        \n        if (event.conferenceData?.conferenceId) {\n          meetingLink = `https://meet.google.com/${event.conferenceData.conferenceId}`;\n        } else if (event.hangoutLink) {\n          meetingLink = event.hangoutLink;\n        } else if (event.description) {\n          // Try to extract meeting links from description\n          const meetPattern = /(https:\\/\\/meet\\.google\\.com\\/[a-z-]+)/i;\n          const teamsPattern = /(https:\\/\\/teams\\.microsoft\\.com\\/[^\\s]+)/i;\n          const zoomPattern = /(https:\\/\\/[a-z0-9.-]+\\.zoom\\.us\\/[^\\s]+)/i;\n          \n          const meetMatch = meetPattern.exec(event.description);\n          const teamsMatch = teamsPattern.exec(event.description);\n          const zoomMatch = zoomPattern.exec(event.description);\n          \n          meetingLink = meetMatch?.[1] || teamsMatch?.[1] || zoomMatch?.[1] || null;\n        }\n        \n        // Format attendees\n        const attendees = (event.attendees || []).map(attendee => ({\n          email: attendee.email || '',\n          name: attendee.displayName || undefined\n        }));\n        \n        // Determine if user is organizer\n        const isOrganizer = event.organizer?.self === true || \n                           event.creator?.self === true;\n        \n        // Format dates correctly\n        const startTime = event.start.dateTime || `${event.start.date}T00:00:00`;\n        const endTime = event.end.dateTime || `${event.end.date}T23:59:59`;\n        \n        allEvents.push({\n          id: event.id,\n          calendar_id: cal.id,\n          title: event.summary,\n          description: event.description || null,\n          start_time: startTime,\n          end_time: endTime,\n          location: event.location || null,\n          meeting_link: meetingLink,\n          attendees,\n          is_organizer: isOrganizer,\n          status: (event.status as 'confirmed' | 'tentative' | 'cancelled') || 'confirmed',\n          html_link: event.htmlLink || '',\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString()\n        });\n      }\n    }\n    \n    return allEvents.sort((a, b) => \n      new Date(a.start_time).getTime() - new Date(b.start_time).getTime()\n    );\n    \n  } catch (error) {\n    console.error('Error fetching Google Calendar events:', error);\n    return [];\n  }\n}\n\n/**\n * Store calendar events in Supabase\n */\nexport async function storeCalendarEvents(userId: string, events: CalendarEvent[]): Promise<boolean> {\n  try {\n    if (events.length === 0) return true;\n    \n    const supabase = createClientClient();\n    \n    // Format events for insertion\n    const formattedEvents = events.map(event => ({\n      user_id: userId,\n      provider: 'google',\n      external_event_id: event.id,\n      calendar_id: event.calendar_id,\n      title: event.title,\n      description: event.description,\n      start_time: event.start_time,\n      end_time: event.end_time,\n      location: event.location,\n      meeting_link: event.meeting_link,\n      attendees: event.attendees,\n      is_organizer: event.is_organizer,\n      status: event.status,\n      html_link: event.html_link,\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString()\n    }));\n    \n    // Upsert events to handle both new and updated events\n    const { error } = await supabase\n      .from('calendar_events')\n      .upsert(formattedEvents, {\n        onConflict: 'user_id,provider,external_event_id'\n      });\n      \n    if (error) {\n      console.error('Error storing calendar events:', error);\n      return false;\n    }\n    \n    // Update last sync timestamp\n    const { error: profileError } = await supabase\n      .from('profiles')\n      .update({ \n        last_calendar_sync: new Date().toISOString()\n      })\n      .eq('id', userId);\n      \n    if (profileError) {\n      console.error('Error updating last sync timestamp:', profileError);\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error storing calendar events:', error);\n    return false;\n  }\n}\n\n/**\n * Sync Google Calendar events to Supabase\n */\nexport async function syncGoogleCalendarEvents(userId: string, daysAhead = 30): Promise<boolean> {\n  try {\n    console.log(`Starting calendar sync for user ${userId}...`);\n    \n    // Refresh token if needed\n    const tokenRefreshed = await refreshTokenIfNeeded(userId);\n    if (!tokenRefreshed) {\n      console.error('Failed to refresh token');\n      return false;\n    }\n    \n    // Fetch events from Google Calendar\n    const events = await fetchUpcomingGoogleEvents(userId, daysAhead);\n    \n    if (events.length === 0) {\n      console.log('No events to sync');\n      return true;\n    }\n    \n    console.log(`Found ${events.length} events to sync`);\n    \n    // Store events in Supabase\n    return await storeCalendarEvents(userId, events);\n  } catch (error) {\n    console.error('Error syncing Google Calendar events:', error);\n    return false;\n  }\n}\n\n/**\n * Check if user has connected their Google Calendar\n */\nexport async function isGoogleCalendarConnected(userId: string): Promise<boolean> {\n  try {\n    const supabase = createClientClient();\n    \n    const { data, error } = await supabase\n      .from('calendar_connections')\n      .select('id')\n      .eq('user_id', userId)\n      .eq('provider', 'google')\n      .single();\n      \n    return !error && !!data;\n  } catch (error) {\n    console.error('Error checking Google Calendar connection:', error);\n    return false;\n  }\n}\n\n/**\n * Disconnect Google Calendar integration\n */\nexport async function disconnectGoogleCalendar(userId: string): Promise<boolean> {\n  try {\n    const supabase = createClientClient();\n    \n    // Delete connection record\n    const { error } = await supabase\n      .from('calendar_connections')\n      .delete()\n      .eq('user_id', userId)\n      .eq('provider', 'google');\n      \n    if (error) {\n      console.error('Error disconnecting Google Calendar:', error);\n      return false;\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error disconnecting Google Calendar:', error);\n    return false;\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 637, "column": 0}, "map": {"version":3,"sources":["file://E%3A/breyholtz%20holding/arti-notes/arti-notes-v2/src/app/api/auth/google/callback/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { handleGoogleCallback } from '@/utils/calendar/google-calendar';\nimport { createClient } from '@/utils/supabase/server';\n\nexport async function GET(request: NextRequest) {\n  // Get the authorization code from the URL\n  const searchParams = request.nextUrl.searchParams;\n  const code = searchParams.get('code');\n  \n  if (!code) {\n    return NextResponse.redirect(new URL('/dashboard?error=Missing authorization code', request.url));\n  }\n  \n  const supabase = await createClient();\n  \n  // Verify user is authenticated\n  const { data: { user }, error } = await supabase.auth.getUser();\n  \n  if (error || !user) {\n    return NextResponse.redirect(new URL('/login?error=Authentication required', request.url));\n  }\n  \n  // Handle the callback\n  const success = await handleGoogleCallback(code);\n  \n  if (!success) {\n    return NextResponse.redirect(new URL('/dashboard?error=Failed to connect Google Calendar', request.url));\n  }\n  \n  // Redirect back to dashboard with success message\n  return NextResponse.redirect(new URL('/dashboard?success=Google Calendar connected', request.url));\n} "],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AAEO,eAAe,IAAI,OAAoB;IAC5C,0CAA0C;IAC1C,MAAM,eAAe,QAAQ,OAAO,CAAC,YAAY;IACjD,MAAM,OAAO,aAAa,GAAG,CAAC;IAE9B,IAAI,CAAC,MAAM;QACT,OAAO,gIAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,+CAA+C,QAAQ,GAAG;IACjG;IAEA,MAAM,WAAW,MAAM,CAAA,GAAA,oIAAA,CAAA,eAAY,AAAD;IAElC,+BAA+B;IAC/B,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,KAAK,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;IAE7D,IAAI,SAAS,CAAC,MAAM;QAClB,OAAO,gIAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,wCAAwC,QAAQ,GAAG;IAC1F;IAEA,sBAAsB;IACtB,MAAM,UAAU,MAAM,CAAA,GAAA,gJAAA,CAAA,uBAAoB,AAAD,EAAE;IAE3C,IAAI,CAAC,SAAS;QACZ,OAAO,gIAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,sDAAsD,QAAQ,GAAG;IACxG;IAEA,kDAAkD;IAClD,OAAO,gIAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,gDAAgD,QAAQ,GAAG;AAClG","debugId":null}}]
}