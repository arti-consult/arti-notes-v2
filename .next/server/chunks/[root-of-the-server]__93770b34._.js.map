{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 252, "column": 0}, "map": {"version":3,"sources":["file:///D:/breyholtz%20holding/arti-notes/arti-notes-v3/src/utils/supabase/client.ts"],"sourcesContent":["import { createBrowserClient } from \"@supabase/ssr\";\r\n\r\nexport function createClient() {\r\n  return createBrowserClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\r\n  );\r\n}\r\n"],"names":[],"mappings":";;;AAAA;AAAA;;AAEO,SAAS;IACd,OAAO,CAAA,GAAA,4KAAA,CAAA,sBAAmB,AAAD;AAI3B","debugId":null}},
    {"offset": {"line": 267, "column": 0}, "map": {"version":3,"sources":["file:///D:/breyholtz%20holding/arti-notes/arti-notes-v3/src/utils/supabase/server.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { createServerClient } from \"@supabase/ssr\";\r\nimport { cookies } from \"next/headers\";\r\n\r\nexport async function createClient() {\r\n  const cookieStore = await cookies();\r\n\r\n  return createServerClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n    {\r\n      cookies: {\r\n        get(name: string) {\r\n          return cookieStore.get(name)?.value;\r\n        },\r\n        set(name: string, value: string, options: any) {\r\n          try {\r\n            cookieStore.set({ name, value, ...options });\r\n          } catch (error) {\r\n            // Handle cookie setting error\r\n            console.error(\"Error setting cookie:\", error);\r\n          }\r\n        },\r\n        remove(name: string, options: any) {\r\n          try {\r\n            cookieStore.set({ name, value: \"\", ...options });\r\n          } catch (error) {\r\n            // Handle cookie removal error\r\n            console.error(\"Error removing cookie:\", error);\r\n          }\r\n        },\r\n      },\r\n    }\r\n  );\r\n}\r\n"],"names":[],"mappings":";;;;;AAEA;AAAA;AACA;;;;;;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,CAAA,GAAA,iIAAA,CAAA,UAAO,AAAD;IAEhC,OAAO,CAAA,GAAA,2KAAA,CAAA,qBAAkB,AAAD,sUAGtB;QACE,SAAS;YACP,KAAI,IAAY;gBACd,OAAO,YAAY,GAAG,CAAC,OAAO;YAChC;YACA,KAAI,IAAY,EAAE,KAAa,EAAE,OAAY;gBAC3C,IAAI;oBACF,YAAY,GAAG,CAAC;wBAAE;wBAAM;wBAAO,GAAG,OAAO;oBAAC;gBAC5C,EAAE,OAAO,OAAO;oBACd,8BAA8B;oBAC9B,QAAQ,KAAK,CAAC,yBAAyB;gBACzC;YACF;YACA,QAAO,IAAY,EAAE,OAAY;gBAC/B,IAAI;oBACF,YAAY,GAAG,CAAC;wBAAE;wBAAM,OAAO;wBAAI,GAAG,OAAO;oBAAC;gBAChD,EAAE,OAAO,OAAO;oBACd,8BAA8B;oBAC9B,QAAQ,KAAK,CAAC,0BAA0B;gBAC1C;YACF;QACF;IACF;AAEJ;;;IA9BsB;;AAAA,iPAAA","debugId":null}},
    {"offset": {"line": 325, "column": 0}, "map": {"version":3,"sources":["file:///D:/breyholtz%20holding/arti-notes/arti-notes-v3/src/utils/calendar/auth.ts"],"sourcesContent":["import { OAuth2Client } from \"google-auth-library\";\r\nimport { createClient } from \"@/utils/supabase/client\";\r\n\r\nconst GOOGLE_CLIENT_ID = process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID!;\r\nconst GOOGLE_CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET!;\r\nconst GOOGLE_REDIRECT_URI = process.env.NEXT_PUBLIC_GOOGLE_REDIRECT_URI!;\r\n\r\nexport async function getGoogleAccessToken(\r\n  userId: string\r\n): Promise<string | null> {\r\n  try {\r\n    console.log(\"Getting Google access token for user:\", userId);\r\n    const supabase = createClient();\r\n\r\n    // Get the user's calendar connection\r\n    const { data: connection, error } = await supabase\r\n      .from(\"calendar_connections\")\r\n      .select(\"*\")\r\n      .eq(\"user_id\", userId)\r\n      .eq(\"provider\", \"google\")\r\n      .single();\r\n\r\n    if (error || !connection) {\r\n      console.error(\"Failed to get calendar connection:\", error);\r\n      return null;\r\n    }\r\n\r\n    console.log(\"Found calendar connection:\", {\r\n      connectionId: connection.id,\r\n      hasRefreshToken: !!connection.refresh_token,\r\n      tokenExpiry: connection.token_expiry,\r\n    });\r\n\r\n    // Create OAuth2 client\r\n    const oauth2Client = new OAuth2Client(\r\n      GOOGLE_CLIENT_ID,\r\n      GOOGLE_CLIENT_SECRET,\r\n      GOOGLE_REDIRECT_URI\r\n    );\r\n\r\n    // Set the refresh token\r\n    oauth2Client.setCredentials({\r\n      refresh_token: connection.refresh_token,\r\n    });\r\n\r\n    // Get fresh access token using refresh token\r\n    const response = await oauth2Client.getAccessToken();\r\n\r\n    if (!response.token) {\r\n      console.error(\"Failed to get access token\");\r\n      return null;\r\n    }\r\n\r\n    // Update the stored tokens\r\n    const { error: updateError } = await supabase\r\n      .from(\"calendar_connections\")\r\n      .update({\r\n        access_token: response.token,\r\n        token_expiry: response.res?.data?.expiry_date\r\n          ? new Date(response.res.data.expiry_date).toISOString()\r\n          : null,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq(\"id\", connection.id);\r\n\r\n    if (updateError) {\r\n      console.error(\"Failed to update tokens:\", updateError);\r\n    } else {\r\n      console.log(\"Successfully updated tokens\");\r\n    }\r\n\r\n    return response.token;\r\n  } catch (error) {\r\n    console.error(\"Error getting Google access token:\", error);\r\n    return null;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEA,MAAM;AACN,MAAM,uBAAuB,QAAQ,GAAG,CAAC,oBAAoB;AAC7D,MAAM,sBAAsB,QAAQ,GAAG,CAAC,+BAA+B;AAEhE,eAAe,qBACpB,MAAc;IAEd,IAAI;QACF,QAAQ,GAAG,CAAC,yCAAyC;QACrD,MAAM,WAAW,CAAA,GAAA,oIAAA,CAAA,eAAY,AAAD;QAE5B,qCAAqC;QACrC,MAAM,EAAE,MAAM,UAAU,EAAE,KAAK,EAAE,GAAG,MAAM,SACvC,IAAI,CAAC,wBACL,MAAM,CAAC,KACP,EAAE,CAAC,WAAW,QACd,EAAE,CAAC,YAAY,UACf,MAAM;QAET,IAAI,SAAS,CAAC,YAAY;YACxB,QAAQ,KAAK,CAAC,sCAAsC;YACpD,OAAO;QACT;QAEA,QAAQ,GAAG,CAAC,8BAA8B;YACxC,cAAc,WAAW,EAAE;YAC3B,iBAAiB,CAAC,CAAC,WAAW,aAAa;YAC3C,aAAa,WAAW,YAAY;QACtC;QAEA,uBAAuB;QACvB,MAAM,eAAe,IAAI,oKAAA,CAAA,eAAY,CACnC,kBACA,sBACA;QAGF,wBAAwB;QACxB,aAAa,cAAc,CAAC;YAC1B,eAAe,WAAW,aAAa;QACzC;QAEA,6CAA6C;QAC7C,MAAM,WAAW,MAAM,aAAa,cAAc;QAElD,IAAI,CAAC,SAAS,KAAK,EAAE;YACnB,QAAQ,KAAK,CAAC;YACd,OAAO;QACT;QAEA,2BAA2B;QAC3B,MAAM,EAAE,OAAO,WAAW,EAAE,GAAG,MAAM,SAClC,IAAI,CAAC,wBACL,MAAM,CAAC;YACN,cAAc,SAAS,KAAK;YAC5B,cAAc,SAAS,GAAG,EAAE,MAAM,cAC9B,IAAI,KAAK,SAAS,GAAG,CAAC,IAAI,CAAC,WAAW,EAAE,WAAW,KACnD;YACJ,YAAY,IAAI,OAAO,WAAW;QACpC,GACC,EAAE,CAAC,MAAM,WAAW,EAAE;QAEzB,IAAI,aAAa;YACf,QAAQ,KAAK,CAAC,4BAA4B;QAC5C,OAAO;YACL,QAAQ,GAAG,CAAC;QACd;QAEA,OAAO,SAAS,KAAK;IACvB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sCAAsC;QACpD,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 385, "column": 0}, "map": {"version":3,"sources":["file:///D:/breyholtz%20holding/arti-notes/arti-notes-v3/src/utils/calendar/google-calendar.ts"],"sourcesContent":["// src/utils/calendar/google-calendar.ts\r\nimport { google } from \"googleapis\";\r\nimport { createClient as createClientClient } from \"@/utils/supabase/client\";\r\nimport { createClient as createClientServer } from \"@/utils/supabase/server\";\r\nimport { CalendarEvent } from \"@/types/calendar\";\r\nimport { getGoogleAccessToken } from \"./auth\";\r\n\r\n// Google OAuth scopes needed\r\nconst SCOPES = [\r\n  \"https://www.googleapis.com/auth/calendar.readonly\",\r\n  \"https://www.googleapis.com/auth/calendar.events.readonly\",\r\n];\r\n\r\n// Google Calendar API credentials\r\nconst credentials = {\r\n  client_id: process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID as string,\r\n  client_secret: process.env.GOOGLE_CLIENT_SECRET as string,\r\n  redirect_uri: `${process.env.NEXT_PUBLIC_APP_URL}/api/auth/google/callback`,\r\n};\r\n\r\n// Debug log the credentials and environment\r\nconsole.log(\"Environment check:\", {\r\n  NODE_ENV: process.env.NODE_ENV,\r\n  APP_URL: process.env.NEXT_PUBLIC_APP_URL,\r\n  hasClientId: !!process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID,\r\n  hasClientSecret: !!process.env.GOOGLE_CLIENT_SECRET,\r\n});\r\n\r\nconsole.log(\"Google OAuth Configuration:\", {\r\n  redirectUri: credentials.redirect_uri,\r\n  hasClientId: !!credentials.client_id,\r\n  hasClientSecret: !!credentials.client_secret,\r\n  scopes: SCOPES,\r\n});\r\n\r\n/**\r\n * Create OAuth2 client for Google API\r\n */\r\nexport function createOAuth2Client() {\r\n  const client = new google.auth.OAuth2(\r\n    credentials.client_id,\r\n    credentials.client_secret,\r\n    credentials.redirect_uri\r\n  );\r\n\r\n  console.log(\r\n    \"Created OAuth2 client with redirect URI:\",\r\n    credentials.redirect_uri\r\n  );\r\n\r\n  return client;\r\n}\r\n\r\n/**\r\n * Generate Google OAuth URL for user authorization\r\n */\r\nexport function getGoogleAuthUrl(): string {\r\n  console.log(\"Generating Google OAuth URL...\");\r\n  const oauth2Client = createOAuth2Client();\r\n\r\n  const url = oauth2Client.generateAuthUrl({\r\n    access_type: \"offline\",\r\n    scope: SCOPES,\r\n    prompt: \"consent\", // Force to get refresh token\r\n    include_granted_scopes: true,\r\n  });\r\n\r\n  console.log(\"Generated OAuth URL:\", url);\r\n  return url;\r\n}\r\n\r\n/**\r\n * Exchange authorization code for tokens and save to Supabase\r\n */\r\nexport async function handleGoogleCallback(code: string): Promise<boolean> {\r\n  try {\r\n    const supabase = await createClientServer();\r\n    const oauth2Client = createOAuth2Client();\r\n\r\n    // Exchange code for tokens\r\n    const { tokens } = await oauth2Client.getToken(code);\r\n\r\n    if (!tokens.access_token || !tokens.refresh_token) {\r\n      console.error(\"Missing required tokens from Google\");\r\n      return false;\r\n    }\r\n\r\n    // Get current user\r\n    const {\r\n      data: { user },\r\n      error: userError,\r\n    } = await supabase.auth.getUser();\r\n\r\n    if (userError || !user) {\r\n      console.error(\"User not authenticated\");\r\n      return false;\r\n    }\r\n\r\n    console.log(\"Saving Google Calendar connection...\");\r\n\r\n    // First, check if a connection already exists\r\n    const { data: existingConnection } = await supabase\r\n      .from(\"calendar_connections\")\r\n      .select(\"id\")\r\n      .eq(\"user_id\", user.id)\r\n      .eq(\"provider\", \"google\")\r\n      .single();\r\n\r\n    // Store tokens in Supabase calendar_connections table\r\n    const connectionData = {\r\n      user_id: user.id,\r\n      provider: \"google\",\r\n      access_token: tokens.access_token,\r\n      refresh_token: tokens.refresh_token,\r\n      token_expiry: tokens.expiry_date\r\n        ? new Date(tokens.expiry_date).toISOString()\r\n        : null,\r\n      scope: SCOPES.join(\" \"),\r\n      updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    let error;\r\n    if (existingConnection) {\r\n      // Update existing connection\r\n      const { error: updateError } = await supabase\r\n        .from(\"calendar_connections\")\r\n        .update(connectionData)\r\n        .eq(\"id\", existingConnection.id);\r\n      error = updateError;\r\n    } else {\r\n      // Create new connection\r\n      const { error: insertError } = await supabase\r\n        .from(\"calendar_connections\")\r\n        .insert({\r\n          ...connectionData,\r\n          created_at: new Date().toISOString(),\r\n        });\r\n      error = insertError;\r\n    }\r\n\r\n    if (error) {\r\n      console.error(\"Error storing tokens:\", error);\r\n      return false;\r\n    }\r\n\r\n    console.log(\"Successfully stored Google Calendar connection\");\r\n    return true;\r\n  } catch (error) {\r\n    console.error(\"Error handling Google callback:\", error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Refresh tokens if needed\r\n */\r\nexport async function refreshTokenIfNeeded(userId: string): Promise<boolean> {\r\n  try {\r\n    const supabase = createClientClient();\r\n\r\n    // Get stored tokens from calendar_connections\r\n    const { data, error } = await supabase\r\n      .from(\"calendar_connections\")\r\n      .select(\"*\")\r\n      .eq(\"user_id\", userId)\r\n      .eq(\"provider\", \"google\")\r\n      .single();\r\n\r\n    if (error || !data) {\r\n      console.error(\"No Google Calendar connection found\");\r\n      return false;\r\n    }\r\n\r\n    // Check if token is expired\r\n    const tokenExpiry = new Date(data.token_expiry);\r\n    const now = new Date();\r\n\r\n    if (tokenExpiry <= now && data.refresh_token) {\r\n      console.log(\"Refreshing expired token...\");\r\n\r\n      // Token is expired, refresh it\r\n      const oauth2Client = createOAuth2Client();\r\n      oauth2Client.setCredentials({\r\n        refresh_token: data.refresh_token,\r\n      });\r\n\r\n      const response = await oauth2Client.getAccessToken();\r\n      const token = response.token;\r\n      const expiryDate = oauth2Client.credentials.expiry_date;\r\n\r\n      // Update tokens in database\r\n      const { error: updateError } = await supabase\r\n        .from(\"calendar_connections\")\r\n        .update({\r\n          access_token: token,\r\n          token_expiry: expiryDate ? new Date(expiryDate).toISOString() : null,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq(\"user_id\", userId)\r\n        .eq(\"provider\", \"google\");\r\n\r\n      if (updateError) {\r\n        console.error(\"Error updating tokens:\", updateError);\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  } catch (error) {\r\n    console.error(\"Error refreshing token:\", error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Fetch upcoming calendar events from Google Calendar\r\n */\r\nexport async function fetchUpcomingGoogleEvents(\r\n  userId: string,\r\n  daysAhead = 30\r\n): Promise<CalendarEvent[]> {\r\n  try {\r\n    console.log(`Fetching Google Calendar events for user ${userId}...`);\r\n\r\n    // Get access token\r\n    const accessToken = await getGoogleAccessToken(userId);\r\n    if (!accessToken) {\r\n      console.error(\"Failed to get access token\");\r\n      return [];\r\n    }\r\n    console.log(\"âœ“ Successfully got access token\");\r\n\r\n    // Setup OAuth client with token\r\n    console.log(\"Setting up OAuth client...\");\r\n    const oauth2Client = new google.auth.OAuth2(\r\n      credentials.client_id,\r\n      credentials.client_secret,\r\n      credentials.redirect_uri\r\n    );\r\n    oauth2Client.setCredentials({ access_token: accessToken });\r\n\r\n    const calendar = google.calendar({ version: \"v3\", auth: oauth2Client });\r\n\r\n    // Calculate time range\r\n    const now = new Date();\r\n    const timeMin = now.toISOString();\r\n    const future = new Date();\r\n    future.setDate(future.getDate() + daysAhead);\r\n    const timeMax = future.toISOString();\r\n\r\n    console.log(`Fetching events from ${timeMin} to ${timeMax}`);\r\n\r\n    // Fetch calendar list first\r\n    console.log(\"Fetching calendar list...\");\r\n    const {\r\n      data: { items: calendarList },\r\n    } = await calendar.calendarList.list();\r\n\r\n    if (!calendarList || calendarList.length === 0) {\r\n      console.log(\"No calendars found\");\r\n      return [];\r\n    }\r\n\r\n    console.log(\r\n      `Found ${calendarList.length} calendars:`,\r\n      calendarList.map((cal) => ({\r\n        id: cal.id,\r\n        summary: cal.summary,\r\n        primary: cal.primary,\r\n      }))\r\n    );\r\n\r\n    // Fetch events from each calendar\r\n    const allEvents: CalendarEvent[] = [];\r\n\r\n    for (const cal of calendarList) {\r\n      if (!cal.id) continue;\r\n\r\n      console.log(`\\nFetching events for calendar: ${cal.summary} (${cal.id})`);\r\n\r\n      const response = await calendar.events.list({\r\n        calendarId: cal.id,\r\n        timeMin,\r\n        timeMax,\r\n        singleEvents: true,\r\n        orderBy: \"startTime\",\r\n      });\r\n\r\n      const events = response.data.items || [];\r\n\r\n      if (events.length === 0) {\r\n        console.log(`No events found for calendar ${cal.summary}`);\r\n        continue;\r\n      }\r\n\r\n      console.log(`Found ${events.length} events for calendar ${cal.summary}`);\r\n\r\n      // Log first 5 events details for debugging\r\n      events.slice(0, 5).forEach((event, index) => {\r\n        console.log(`\\nEvent ${index + 1}:`, {\r\n          id: event.id,\r\n          summary: event.summary,\r\n          start: event.start?.dateTime || event.start?.date,\r\n          end: event.end?.dateTime || event.end?.date,\r\n          attendees: event.attendees?.length || 0,\r\n          hasHangoutLink: !!event.hangoutLink,\r\n          hasConferenceData: !!event.conferenceData,\r\n          organizer: event.organizer?.email,\r\n          status: event.status,\r\n        });\r\n      });\r\n\r\n      for (const event of events) {\r\n        if (!event.id || !event.summary) continue;\r\n\r\n        // Get meeting link\r\n        let meetingLink: string | null = null;\r\n        if (event.hangoutLink) {\r\n          meetingLink = event.hangoutLink;\r\n        } else if (event.conferenceData?.entryPoints) {\r\n          const videoEntry = event.conferenceData.entryPoints.find(\r\n            (entry) => entry.entryPointType === \"video\"\r\n          );\r\n          if (videoEntry?.uri) {\r\n            meetingLink = videoEntry.uri;\r\n          }\r\n        }\r\n\r\n        // Get attendees\r\n        const attendees =\r\n          event.attendees?.map((attendee) => ({\r\n            email: attendee.email || \"\",\r\n            name: attendee.displayName || undefined,\r\n          })) || [];\r\n\r\n        // Check if user is organizer\r\n        const isOrganizer =\r\n          event.organizer?.email ===\r\n          event.attendees?.find((attendee) => attendee.self)?.email;\r\n\r\n        // Format dates correctly\r\n        const startTime =\r\n          event.start?.dateTime ||\r\n          (event.start?.date ? `${event.start.date}T00:00:00` : null);\r\n        const endTime =\r\n          event.end?.dateTime ||\r\n          (event.end?.date ? `${event.end.date}T23:59:59` : null);\r\n\r\n        if (!startTime || !endTime) continue;\r\n\r\n        allEvents.push({\r\n          id: event.id,\r\n          calendar_id: cal.id,\r\n          title: event.summary,\r\n          description: event.description || null,\r\n          start_time: startTime,\r\n          end_time: endTime,\r\n          location: event.location || null,\r\n          meeting_link: meetingLink,\r\n          attendees,\r\n          is_organizer: isOrganizer,\r\n          status:\r\n            (event.status as \"confirmed\" | \"tentative\" | \"cancelled\") ||\r\n            \"confirmed\",\r\n          html_link: event.htmlLink || \"\",\r\n          created_at: new Date().toISOString(),\r\n          updated_at: new Date().toISOString(),\r\n        });\r\n      }\r\n    }\r\n\r\n    console.log(\r\n      `\\nTotal events found across all calendars: ${allEvents.length}`\r\n    );\r\n    console.log(\r\n      \"First 3 processed events:\",\r\n      allEvents.slice(0, 3).map((event) => ({\r\n        title: event.title,\r\n        start: event.start_time,\r\n        end: event.end_time,\r\n        attendees: event.attendees.length,\r\n        has_meeting: !!event.meeting_link,\r\n      }))\r\n    );\r\n\r\n    return allEvents.sort(\r\n      (a, b) =>\r\n        new Date(a.start_time).getTime() - new Date(b.start_time).getTime()\r\n    );\r\n  } catch (error) {\r\n    console.error(\"Error fetching Google Calendar events:\", error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Store calendar events in Supabase\r\n */\r\nexport async function storeCalendarEvents(\r\n  userId: string,\r\n  events: CalendarEvent[]\r\n): Promise<boolean> {\r\n  try {\r\n    console.log(`Storing ${events.length} calendar events in Supabase...`);\r\n\r\n    if (events.length === 0) {\r\n      console.log(\"No events to store\");\r\n      return true;\r\n    }\r\n\r\n    const supabase = createClientClient();\r\n\r\n    // Format events for insertion\r\n    const formattedEvents = events.map((event) => ({\r\n      user_id: userId,\r\n      provider: \"google\",\r\n      external_event_id: event.id,\r\n      calendar_id: event.calendar_id,\r\n      title: event.title,\r\n      description: event.description,\r\n      start_time: event.start_time,\r\n      end_time: event.end_time,\r\n      location: event.location,\r\n      meeting_link: event.meeting_link,\r\n      attendees: event.attendees,\r\n      is_organizer: event.is_organizer,\r\n      status: event.status,\r\n      html_link: event.html_link,\r\n      created_at: new Date().toISOString(),\r\n      updated_at: new Date().toISOString(),\r\n    }));\r\n\r\n    console.log(\"Upserting events to Supabase...\");\r\n\r\n    // Upsert events to handle both new and updated events\r\n    const { error } = await supabase\r\n      .from(\"calendar_events\")\r\n      .upsert(formattedEvents, {\r\n        onConflict: \"user_id,provider,external_event_id\",\r\n      });\r\n\r\n    if (error) {\r\n      console.error(\"Error storing calendar events:\", error);\r\n      return false;\r\n    }\r\n\r\n    console.log(\"Events stored successfully\");\r\n\r\n    // Update last sync timestamp\r\n    console.log(\"Updating last sync timestamp...\");\r\n    const { error: profileError } = await supabase\r\n      .from(\"profiles\")\r\n      .update({\r\n        last_calendar_sync: new Date().toISOString(),\r\n      })\r\n      .eq(\"id\", userId);\r\n\r\n    if (profileError) {\r\n      console.error(\"Error updating last sync timestamp:\", profileError);\r\n    }\r\n\r\n    return true;\r\n  } catch (error) {\r\n    console.error(\"Error storing calendar events:\", error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Sync Google Calendar events to Supabase\r\n */\r\nexport async function syncGoogleCalendarEvents(\r\n  userId: string,\r\n  daysAhead = 30\r\n): Promise<boolean> {\r\n  try {\r\n    console.log(`Starting calendar sync for user ${userId}...`);\r\n\r\n    // Get access token\r\n    const accessToken = await getGoogleAccessToken(userId);\r\n    if (!accessToken) {\r\n      console.error(\"Failed to get access token\");\r\n      return false;\r\n    }\r\n\r\n    console.log(\"Successfully got access token\");\r\n\r\n    // Fetch events from Google Calendar\r\n    const events = await fetchUpcomingGoogleEvents(userId, daysAhead);\r\n\r\n    if (events.length === 0) {\r\n      console.log(\"No events to sync\");\r\n      return true;\r\n    }\r\n\r\n    console.log(`Found ${events.length} events to sync`);\r\n\r\n    // Store events in Supabase\r\n    const success = await storeCalendarEvents(userId, events);\r\n\r\n    if (!success) {\r\n      console.error(\"Failed to store calendar events\");\r\n      return false;\r\n    }\r\n\r\n    console.log(\"Successfully synced calendar events\");\r\n    return true;\r\n  } catch (error) {\r\n    console.error(\"Error syncing Google Calendar events:\", error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Check if user has connected their Google Calendar\r\n */\r\nexport async function isGoogleCalendarConnected(\r\n  userId: string\r\n): Promise<boolean> {\r\n  try {\r\n    const supabase = createClientClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from(\"calendar_connections\")\r\n      .select(\"id\")\r\n      .eq(\"user_id\", userId)\r\n      .eq(\"provider\", \"google\")\r\n      .single();\r\n\r\n    return !error && !!data;\r\n  } catch (error) {\r\n    console.error(\"Error checking Google Calendar connection:\", error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Disconnect Google Calendar integration\r\n */\r\nexport async function disconnectGoogleCalendar(\r\n  userId: string\r\n): Promise<boolean> {\r\n  try {\r\n    const supabase = createClientClient();\r\n\r\n    // Delete connection record\r\n    const { error } = await supabase\r\n      .from(\"calendar_connections\")\r\n      .delete()\r\n      .eq(\"user_id\", userId)\r\n      .eq(\"provider\", \"google\");\r\n\r\n    if (error) {\r\n      console.error(\"Error disconnecting Google Calendar:\", error);\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  } catch (error) {\r\n    console.error(\"Error disconnecting Google Calendar:\", error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 776, "column": 0}, "map": {"version":3,"sources":["file:///D:/breyholtz%20holding/arti-notes/arti-notes-v3/src/app/api/auth/google/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport { getGoogleAuthUrl } from \"@/utils/calendar/google-calendar\";\r\nimport { createClient } from \"@/utils/supabase/server\";\r\n\r\nexport async function GET(_request: NextRequest) {\r\n  try {\r\n    console.log(\"Starting Google OAuth flow...\");\r\n\r\n    const supabase = await createClient();\r\n\r\n    // Verify user is authenticated\r\n    const {\r\n      data: { user },\r\n      error,\r\n    } = await supabase.auth.getUser();\r\n\r\n    if (error) {\r\n      console.error(\"Supabase auth error:\", error);\r\n      return NextResponse.json(\r\n        { error: \"Authentication required\" },\r\n        {\r\n          status: 401,\r\n          headers: {\r\n            \"Content-Type\": \"application/json\",\r\n          },\r\n        }\r\n      );\r\n    }\r\n\r\n    if (!user) {\r\n      console.error(\"No user found in session\");\r\n      return NextResponse.json(\r\n        { error: \"Authentication required\" },\r\n        {\r\n          status: 401,\r\n          headers: {\r\n            \"Content-Type\": \"application/json\",\r\n          },\r\n        }\r\n      );\r\n    }\r\n\r\n    console.log(\"User authenticated:\", { userId: user.id, email: user.email });\r\n\r\n    // Generate Google OAuth URL\r\n    const authUrl = getGoogleAuthUrl();\r\n    console.log(\"Generated OAuth URL:\", authUrl);\r\n\r\n    return NextResponse.json(\r\n      { url: authUrl },\r\n      {\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n        },\r\n      }\r\n    );\r\n  } catch (error) {\r\n    console.error(\"Error in Google auth route:\", error);\r\n    return NextResponse.json(\r\n      {\r\n        error: \"Failed to generate Google auth URL\",\r\n        details: error instanceof Error ? error.message : String(error),\r\n      },\r\n      {\r\n        status: 500,\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n        },\r\n      }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AAEO,eAAe,IAAI,QAAqB;IAC7C,IAAI;QACF,QAAQ,GAAG,CAAC;QAEZ,MAAM,WAAW,MAAM,CAAA,GAAA,oIAAA,CAAA,eAAY,AAAD;QAElC,+BAA+B;QAC/B,MAAM,EACJ,MAAM,EAAE,IAAI,EAAE,EACd,KAAK,EACN,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;QAE/B,IAAI,OAAO;YACT,QAAQ,KAAK,CAAC,wBAAwB;YACtC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA0B,GACnC;gBACE,QAAQ;gBACR,SAAS;oBACP,gBAAgB;gBAClB;YACF;QAEJ;QAEA,IAAI,CAAC,MAAM;YACT,QAAQ,KAAK,CAAC;YACd,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA0B,GACnC;gBACE,QAAQ;gBACR,SAAS;oBACP,gBAAgB;gBAClB;YACF;QAEJ;QAEA,QAAQ,GAAG,CAAC,uBAAuB;YAAE,QAAQ,KAAK,EAAE;YAAE,OAAO,KAAK,KAAK;QAAC;QAExE,4BAA4B;QAC5B,MAAM,UAAU,CAAA,GAAA,gJAAA,CAAA,mBAAgB,AAAD;QAC/B,QAAQ,GAAG,CAAC,wBAAwB;QAEpC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,KAAK;QAAQ,GACf;YACE,SAAS;gBACP,gBAAgB;YAClB;QACF;IAEJ,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YACE,OAAO;YACP,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG,OAAO;QAC3D,GACA;YACE,QAAQ;YACR,SAAS;gBACP,gBAAgB;YAClB;QACF;IAEJ;AACF","debugId":null}}]
}