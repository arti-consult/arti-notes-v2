module.exports = {

"[project]/.next-internal/server/app/api/auth/google/callback/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/child_process [external] (child_process, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[externals]/net [external] (net, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}}),
"[externals]/tls [external] (tls, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}}),
"[externals]/assert [external] (assert, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}}),
"[externals]/tty [external] (tty, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/punycode [external] (punycode, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/querystring [external] (querystring, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/node:events [external] (node:events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:events", () => require("node:events"));

module.exports = mod;
}}),
"[externals]/node:process [external] (node:process, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:process", () => require("node:process"));

module.exports = mod;
}}),
"[externals]/node:util [external] (node:util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:util", () => require("node:util"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/http2 [external] (http2, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http2", () => require("http2"));

module.exports = mod;
}}),
"[externals]/process [external] (process, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}}),
"[project]/src/utils/supabase/client.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createClient": (()=>createClient)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/ssr/dist/module/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createBrowserClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/ssr/dist/module/createBrowserClient.js [app-route] (ecmascript)");
;
function createClient() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createBrowserClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createBrowserClient"])(("TURBOPACK compile-time value", "https://wnxwqdupndeqijmamdkp.supabase.co"), ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndueHdxZHVwbmRlcWlqbWFtZGtwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzE4NDU4NTksImV4cCI6MjA0NzQyMTg1OX0.pJ2CF508xkmP2IPEoSkqJ45lMmNySVxHJYxeZ_Ge3Pw"));
}
}}),
"[project]/src/utils/supabase/server.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createClient": (()=>createClient)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/ssr/dist/module/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/ssr/dist/module/createServerClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/headers.js [app-route] (ecmascript)");
;
;
async function createClient() {
    const cookieStore = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createServerClient"])(("TURBOPACK compile-time value", "https://wnxwqdupndeqijmamdkp.supabase.co"), ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndueHdxZHVwbmRlcWlqbWFtZGtwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzE4NDU4NTksImV4cCI6MjA0NzQyMTg1OX0.pJ2CF508xkmP2IPEoSkqJ45lMmNySVxHJYxeZ_Ge3Pw"), {
        cookies: {
            get (name) {
                return cookieStore.get(name)?.value;
            },
            set (name, value, options) {
                cookieStore.set({
                    name,
                    value,
                    ...options
                });
            },
            remove (name, options) {
                cookieStore.set({
                    name,
                    value: "",
                    ...options
                });
            }
        }
    });
}
}}),
"[project]/src/utils/calendar/google-calendar.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/utils/calendar/google-calendar.ts
__turbopack_context__.s({
    "createOAuth2Client": (()=>createOAuth2Client),
    "disconnectGoogleCalendar": (()=>disconnectGoogleCalendar),
    "fetchUpcomingGoogleEvents": (()=>fetchUpcomingGoogleEvents),
    "getGoogleAuthUrl": (()=>getGoogleAuthUrl),
    "handleGoogleCallback": (()=>handleGoogleCallback),
    "isGoogleCalendarConnected": (()=>isGoogleCalendarConnected),
    "refreshTokenIfNeeded": (()=>refreshTokenIfNeeded),
    "storeCalendarEvents": (()=>storeCalendarEvents),
    "syncGoogleCalendarEvents": (()=>syncGoogleCalendarEvents)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/googleapis/build/src/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/supabase/client.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/supabase/server.ts [app-route] (ecmascript)");
;
;
;
// Google OAuth scopes needed
const SCOPES = [
    'https://www.googleapis.com/auth/calendar.readonly',
    'https://www.googleapis.com/auth/calendar.events.readonly'
];
// Google Calendar API credentials
const credentials = {
    client_id: ("TURBOPACK compile-time value", "438777486938-3qirleero26ui3t8e0svrojd89jrhpvs.apps.googleusercontent.com"),
    client_secret: process.env.GOOGLE_CLIENT_SECRET,
    redirect_uri: `${("TURBOPACK compile-time value", "http://localhost:3000")}/api/auth/google/callback`
};
// Debug log the credentials and environment
console.log('Environment check:', {
    NODE_ENV: ("TURBOPACK compile-time value", "development"),
    APP_URL: ("TURBOPACK compile-time value", "http://localhost:3000"),
    hasClientId: !!("TURBOPACK compile-time value", "438777486938-3qirleero26ui3t8e0svrojd89jrhpvs.apps.googleusercontent.com"),
    hasClientSecret: !!process.env.GOOGLE_CLIENT_SECRET
});
console.log('Google OAuth Configuration:', {
    redirectUri: credentials.redirect_uri,
    hasClientId: !!credentials.client_id,
    hasClientSecret: !!credentials.client_secret,
    scopes: SCOPES
});
function createOAuth2Client() {
    const client = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].auth.OAuth2(credentials.client_id, credentials.client_secret, credentials.redirect_uri);
    console.log('Created OAuth2 client with redirect URI:', credentials.redirect_uri);
    return client;
}
function getGoogleAuthUrl() {
    console.log('Generating Google OAuth URL...');
    const oauth2Client = createOAuth2Client();
    const url = oauth2Client.generateAuthUrl({
        access_type: 'offline',
        scope: SCOPES,
        prompt: 'consent',
        include_granted_scopes: true
    });
    console.log('Generated OAuth URL:', url);
    return url;
}
async function handleGoogleCallback(code) {
    try {
        const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        const oauth2Client = createOAuth2Client();
        // Exchange code for tokens
        const { tokens } = await oauth2Client.getToken(code);
        // Get current user
        const { data: { user }, error: userError } = await supabase.auth.getUser();
        if (userError || !user) {
            console.error('User not authenticated');
            return false;
        }
        console.log('Saving Google Calendar connection...');
        // Store tokens in Supabase calendar_connections table
        const { error } = await supabase.from('calendar_connections').upsert({
            user_id: user.id,
            provider: 'google',
            access_token: tokens.access_token,
            refresh_token: tokens.refresh_token,
            token_expiry: tokens.expiry_date ? new Date(tokens.expiry_date).toISOString() : null,
            scope: SCOPES.join(' '),
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
        }, {
            onConflict: 'user_id,provider'
        });
        if (error) {
            console.error('Error storing tokens:', error);
            return false;
        }
        return true;
    } catch (error) {
        console.error('Error handling Google callback:', error);
        return false;
    }
}
async function refreshTokenIfNeeded(userId) {
    try {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Get stored tokens from calendar_connections
        const { data, error } = await supabase.from('calendar_connections').select('*').eq('user_id', userId).eq('provider', 'google').single();
        if (error || !data) {
            console.error('No Google Calendar connection found');
            return false;
        }
        // Check if token is expired
        const tokenExpiry = new Date(data.token_expiry);
        const now = new Date();
        if (tokenExpiry <= now && data.refresh_token) {
            console.log('Refreshing expired token...');
            // Token is expired, refresh it
            const oauth2Client = createOAuth2Client();
            oauth2Client.setCredentials({
                refresh_token: data.refresh_token
            });
            const response = await oauth2Client.getAccessToken();
            const token = response.token;
            const expiryDate = oauth2Client.credentials.expiry_date;
            // Update tokens in database
            const { error: updateError } = await supabase.from('calendar_connections').update({
                access_token: token,
                token_expiry: expiryDate ? new Date(expiryDate).toISOString() : null,
                updated_at: new Date().toISOString()
            }).eq('user_id', userId).eq('provider', 'google');
            if (updateError) {
                console.error('Error updating tokens:', updateError);
                return false;
            }
        }
        return true;
    } catch (error) {
        console.error('Error refreshing token:', error);
        return false;
    }
}
async function fetchUpcomingGoogleEvents(userId, daysAhead = 30) {
    try {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Get stored tokens
        const { data: connectionData, error: connectionError } = await supabase.from('calendar_connections').select('*').eq('user_id', userId).eq('provider', 'google').single();
        if (connectionError || !connectionData) {
            console.error('No Google Calendar connection found');
            return [];
        }
        // Refresh token if needed
        await refreshTokenIfNeeded(userId);
        // Setup OAuth client with token
        const oauth2Client = createOAuth2Client();
        oauth2Client.setCredentials({
            access_token: connectionData.access_token,
            refresh_token: connectionData.refresh_token
        });
        const calendar = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].calendar({
            version: 'v3',
            auth: oauth2Client
        });
        // Calculate time range
        const now = new Date();
        const timeMin = now.toISOString();
        const future = new Date();
        future.setDate(future.getDate() + daysAhead);
        const timeMax = future.toISOString();
        // Fetch calendar list first
        const { data: { items: calendarList } } = await calendar.calendarList.list();
        if (!calendarList || calendarList.length === 0) {
            return [];
        }
        // Fetch events from each calendar
        const allEvents = [];
        for (const cal of calendarList){
            if (!cal.id) continue;
            const { data } = await calendar.events.list({
                calendarId: cal.id,
                timeMin,
                timeMax,
                singleEvents: true,
                orderBy: 'startTime',
                maxResults: 100
            });
            if (!data.items || data.items.length === 0) continue;
            // Transform events to our format
            for (const event of data.items){
                if (!event.id || !event.summary) continue;
                // Skip events without start/end times
                if (!event.start || !event.end) continue;
                // Get meeting links from conference data or description
                let meetingLink = null;
                if (event.conferenceData?.conferenceId) {
                    meetingLink = `https://meet.google.com/${event.conferenceData.conferenceId}`;
                } else if (event.hangoutLink) {
                    meetingLink = event.hangoutLink;
                } else if (event.description) {
                    // Try to extract meeting links from description
                    const meetPattern = /(https:\/\/meet\.google\.com\/[a-z-]+)/i;
                    const teamsPattern = /(https:\/\/teams\.microsoft\.com\/[^\s]+)/i;
                    const zoomPattern = /(https:\/\/[a-z0-9.-]+\.zoom\.us\/[^\s]+)/i;
                    const meetMatch = meetPattern.exec(event.description);
                    const teamsMatch = teamsPattern.exec(event.description);
                    const zoomMatch = zoomPattern.exec(event.description);
                    meetingLink = meetMatch?.[1] || teamsMatch?.[1] || zoomMatch?.[1] || null;
                }
                // Format attendees
                const attendees = (event.attendees || []).map((attendee)=>({
                        email: attendee.email || '',
                        name: attendee.displayName || undefined
                    }));
                // Determine if user is organizer
                const isOrganizer = event.organizer?.self === true || event.creator?.self === true;
                // Format dates correctly
                const startTime = event.start.dateTime || `${event.start.date}T00:00:00`;
                const endTime = event.end.dateTime || `${event.end.date}T23:59:59`;
                allEvents.push({
                    id: event.id,
                    calendar_id: cal.id,
                    title: event.summary,
                    description: event.description || null,
                    start_time: startTime,
                    end_time: endTime,
                    location: event.location || null,
                    meeting_link: meetingLink,
                    attendees,
                    is_organizer: isOrganizer,
                    status: event.status || 'confirmed',
                    html_link: event.htmlLink || '',
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString()
                });
            }
        }
        return allEvents.sort((a, b)=>new Date(a.start_time).getTime() - new Date(b.start_time).getTime());
    } catch (error) {
        console.error('Error fetching Google Calendar events:', error);
        return [];
    }
}
async function storeCalendarEvents(userId, events) {
    try {
        if (events.length === 0) return true;
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Format events for insertion
        const formattedEvents = events.map((event)=>({
                user_id: userId,
                provider: 'google',
                external_event_id: event.id,
                calendar_id: event.calendar_id,
                title: event.title,
                description: event.description,
                start_time: event.start_time,
                end_time: event.end_time,
                location: event.location,
                meeting_link: event.meeting_link,
                attendees: event.attendees,
                is_organizer: event.is_organizer,
                status: event.status,
                html_link: event.html_link,
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
            }));
        // Upsert events to handle both new and updated events
        const { error } = await supabase.from('calendar_events').upsert(formattedEvents, {
            onConflict: 'user_id,provider,external_event_id'
        });
        if (error) {
            console.error('Error storing calendar events:', error);
            return false;
        }
        // Update last sync timestamp
        const { error: profileError } = await supabase.from('profiles').update({
            last_calendar_sync: new Date().toISOString()
        }).eq('id', userId);
        if (profileError) {
            console.error('Error updating last sync timestamp:', profileError);
        }
        return true;
    } catch (error) {
        console.error('Error storing calendar events:', error);
        return false;
    }
}
async function syncGoogleCalendarEvents(userId, daysAhead = 30) {
    try {
        console.log(`Starting calendar sync for user ${userId}...`);
        // Refresh token if needed
        const tokenRefreshed = await refreshTokenIfNeeded(userId);
        if (!tokenRefreshed) {
            console.error('Failed to refresh token');
            return false;
        }
        // Fetch events from Google Calendar
        const events = await fetchUpcomingGoogleEvents(userId, daysAhead);
        if (events.length === 0) {
            console.log('No events to sync');
            return true;
        }
        console.log(`Found ${events.length} events to sync`);
        // Store events in Supabase
        return await storeCalendarEvents(userId, events);
    } catch (error) {
        console.error('Error syncing Google Calendar events:', error);
        return false;
    }
}
async function isGoogleCalendarConnected(userId) {
    try {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        const { data, error } = await supabase.from('calendar_connections').select('id').eq('user_id', userId).eq('provider', 'google').single();
        return !error && !!data;
    } catch (error) {
        console.error('Error checking Google Calendar connection:', error);
        return false;
    }
}
async function disconnectGoogleCalendar(userId) {
    try {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Delete connection record
        const { error } = await supabase.from('calendar_connections').delete().eq('user_id', userId).eq('provider', 'google');
        if (error) {
            console.error('Error disconnecting Google Calendar:', error);
            return false;
        }
        return true;
    } catch (error) {
        console.error('Error disconnecting Google Calendar:', error);
        return false;
    }
}
}}),
"[project]/src/services/calendarEventService.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/utils/calendar/calendar-events-service.ts
__turbopack_context__.s({
    "createMeetingsFromCalendarEvents": (()=>createMeetingsFromCalendarEvents),
    "determineMeetingType": (()=>determineMeetingType),
    "getSyncedCalendarEvents": (()=>getSyncedCalendarEvents),
    "getUpcomingCalendarEventsWithMeetingLinks": (()=>getUpcomingCalendarEventsWithMeetingLinks),
    "updateMeetingsFromCalendarEvents": (()=>updateMeetingsFromCalendarEvents)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/supabase/client.ts [app-route] (ecmascript)");
;
async function getUpcomingCalendarEventsWithMeetingLinks(daysAhead = 7) {
    try {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Get upcoming events with meeting links
        const { data, error } = await supabase.from('calendar_events').select('*').not('meeting_link', 'is', null).gte('start_time', new Date().toISOString()).lte('start_time', new Date(Date.now() + daysAhead * 24 * 60 * 60 * 1000).toISOString()).order('start_time', {
            ascending: true
        });
        if (error) {
            console.error('Error fetching upcoming events:', error);
            return [];
        }
        return data || [];
    } catch (error) {
        console.error('Error fetching upcoming events:', error);
        return [];
    }
}
function determineMeetingType(meetingLink) {
    const lowerCaseLink = meetingLink.toLowerCase();
    if (lowerCaseLink.includes('meet.google.com')) {
        return 'google-meets';
    } else if (lowerCaseLink.includes('teams.microsoft.com')) {
        return 'microsoft-teams';
    } else {
        return 'live';
    }
}
async function createMeetingsFromCalendarEvents() {
    try {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Get upcoming events with meeting links that haven't been synced
        const { data: events, error } = await supabase.from('calendar_events').select('*').not('meeting_link', 'is', null).eq('synced_to_meeting', false).gte('start_time', new Date().toISOString()).order('start_time', {
            ascending: true
        });
        if (error) {
            console.error('Error fetching calendar events:', error);
            return 0;
        }
        if (!events || events.length === 0) {
            return 0;
        }
        let syncedCount = 0;
        // Process each event
        for (const event of events){
            if (!event.meeting_link) continue;
            // Determine meeting type
            const meetingType = determineMeetingType(event.meeting_link);
            // Create meeting
            const { data: meeting, error: meetingError } = await supabase.from('meetings').insert({
                title: event.title,
                description: event.description,
                user_id: event.user_id,
                meeting_type: meetingType,
                start_time: event.start_time,
                end_time: event.end_time,
                calendar_event_id: event.id,
                meeting_url: event.meeting_link,
                attendees: event.attendees,
                location: event.location,
                status: 'scheduled',
                transcription_status: 'pending',
                summary_status: 'pending'
            }).select('id').single();
            if (meetingError) {
                console.error('Error creating meeting from calendar event:', meetingError);
                continue;
            }
            // Update calendar event with meeting ID
            const { error: updateError } = await supabase.from('calendar_events').update({
                synced_to_meeting: true,
                meeting_id: meeting.id
            }).eq('id', event.id);
            if (updateError) {
                console.error('Error updating calendar event:', updateError);
                continue;
            }
            syncedCount++;
        }
        return syncedCount;
    } catch (error) {
        console.error('Error creating meetings from calendar events:', error);
        return 0;
    }
}
async function getSyncedCalendarEvents() {
    try {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Get events that have been synced to meetings
        const { data, error } = await supabase.from('calendar_events').select(`
        *,
        meetings:meeting_id (
          id,
          title,
          start_time,
          end_time,
          meeting_type,
          transcription_status,
          summary_status
        )
      `).eq('synced_to_meeting', true).order('start_time', {
            ascending: false
        });
        if (error) {
            console.error('Error fetching synced events:', error);
            return [];
        }
        return data || [];
    } catch (error) {
        console.error('Error fetching synced events:', error);
        return [];
    }
}
async function updateMeetingsFromCalendarEvents() {
    try {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Get synced events
        const { data: events, error } = await supabase.from('calendar_events').select(`
        *,
        meetings:meeting_id (
          id,
          title,
          start_time,
          end_time
        )
      `).eq('synced_to_meeting', true).not('meeting_id', 'is', null);
        if (error) {
            console.error('Error fetching synced events:', error);
            return 0;
        }
        if (!events || events.length === 0) {
            return 0;
        }
        let updatedCount = 0;
        // Process each event
        for (const event of events){
            if (!event.meeting_id || !event.meetings) continue;
            const meeting = event.meetings;
            // Check if meeting needs updating
            if (meeting.title !== event.title || meeting.start_time !== event.start_time || meeting.end_time !== event.end_time) {
                // Update meeting
                const { error: updateError } = await supabase.from('meetings').update({
                    title: event.title,
                    start_time: event.start_time,
                    end_time: event.end_time,
                    updated_at: new Date().toISOString()
                }).eq('id', event.meeting_id);
                if (updateError) {
                    console.error('Error updating meeting:', updateError);
                    continue;
                }
                updatedCount++;
            }
        }
        return updatedCount;
    } catch (error) {
        console.error('Error updating meetings from calendar events:', error);
        return 0;
    }
}
}}),
"[project]/src/utils/calendar/background-sync.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/utils/calendar/background-sync.ts
__turbopack_context__.s({
    "syncAllUserCalendars": (()=>syncAllUserCalendars),
    "syncUserCalendar": (()=>syncUserCalendar)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/supabase/server.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$calendar$2f$google$2d$calendar$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/calendar/google-calendar.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$calendarEventService$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/services/calendarEventService.ts [app-route] (ecmascript)");
;
;
;
async function syncUserCalendar(userId) {
    try {
        console.log(`Starting calendar sync for user ${userId}...`);
        const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // 1. Verify calendar connection
        const { data: connection, error: connectionError } = await supabase.from('calendar_connections').select('*').eq('user_id', userId).eq('provider', 'google').single();
        if (connectionError || !connection) {
            console.error('No valid calendar connection found:', connectionError);
            return false;
        }
        console.log('Found valid calendar connection, syncing Google Calendar events...');
        // 2. Sync Google Calendar events
        const calendarSyncSuccess = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$calendar$2f$google$2d$calendar$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["syncGoogleCalendarEvents"])(userId);
        if (!calendarSyncSuccess) {
            console.error('Failed to sync Google Calendar events');
            return false;
        }
        console.log('Google Calendar events synced, creating meetings...');
        // 3. Create meetings from calendar events with meeting links
        const createdMeetings = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$calendarEventService$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createMeetingsFromCalendarEvents"])();
        console.log(`Created ${createdMeetings} meetings from calendar events`);
        // 4. Update existing meetings if calendar events have changed
        const updatedMeetings = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$calendarEventService$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["updateMeetingsFromCalendarEvents"])();
        console.log(`Updated ${updatedMeetings} existing meetings`);
        // 5. Update last sync timestamp
        const { error: updateError } = await supabase.from('profiles').update({
            last_calendar_sync: new Date().toISOString()
        }).eq('id', userId);
        if (updateError) {
            console.error('Failed to update last sync timestamp:', updateError);
        }
        // 6. Get final event count
        const { count } = await supabase.from('calendar_events').select('*', {
            count: 'exact',
            head: true
        }).eq('user_id', userId);
        console.log('Calendar sync completed successfully', {
            userId,
            totalEvents: count,
            createdMeetings,
            updatedMeetings
        });
        return true;
    } catch (error) {
        console.error('Error in complete user calendar sync:', error);
        return false;
    }
}
async function syncAllUserCalendars() {
    try {
        const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Get all users with their sync frequency
        const { data: profiles, error } = await supabase.from('profiles').select(`
        id,
        calendar_sync_frequency,
        last_calendar_sync
      `).not('calendar_sync_frequency', 'eq', 'manual');
        if (error) {
            console.error('Error fetching user profiles:', error);
            return {
                success: false,
                syncedUsers: 0
            };
        }
        if (!profiles || profiles.length === 0) {
            return {
                success: true,
                syncedUsers: 0
            };
        }
        let syncedUsers = 0;
        const now = new Date();
        // Process each user based on their sync frequency
        for (const profile of profiles){
            // Skip if no sync frequency
            if (!profile.calendar_sync_frequency) continue;
            const lastSync = profile.last_calendar_sync ? new Date(profile.last_calendar_sync) : null;
            let shouldSync = false;
            // Determine if we should sync based on frequency
            switch(profile.calendar_sync_frequency){
                case 'realtime':
                    shouldSync = true;
                    break;
                case 'hourly':
                    shouldSync = !lastSync || now.getTime() - lastSync.getTime() >= 60 * 60 * 1000;
                    break;
                case 'daily':
                    shouldSync = !lastSync || now.getTime() - lastSync.getTime() >= 24 * 60 * 60 * 1000;
                    break;
                case 'weekly':
                    shouldSync = !lastSync || now.getTime() - lastSync.getTime() >= 7 * 24 * 60 * 60 * 1000;
                    break;
                default:
                    shouldSync = false;
            }
            if (shouldSync) {
                // Use the new syncUserCalendar function for consistency
                const success = await syncUserCalendar(profile.id);
                if (success) {
                    syncedUsers++;
                }
            }
        }
        return {
            success: true,
            syncedUsers
        };
    } catch (error) {
        console.error('Error syncing user calendars:', error);
        return {
            success: false,
            syncedUsers: 0
        };
    }
}
}}),
"[project]/src/app/api/auth/google/callback/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GET": (()=>GET)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$calendar$2f$google$2d$calendar$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/calendar/google-calendar.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/supabase/server.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$calendar$2f$background$2d$sync$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/calendar/background-sync.ts [app-route] (ecmascript)");
;
;
;
;
async function GET(request) {
    try {
        console.log('Starting Google OAuth callback handler...');
        // Get the authorization code from the URL
        const searchParams = new URL(request.url).searchParams;
        const code = searchParams.get('code');
        if (!code) {
            console.error('No authorization code received in callback');
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].redirect(new URL('/dashboard?error=Missing authorization code', request.url));
        }
        console.log('Received authorization code, verifying user...');
        const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Verify user is authenticated
        const { data: { user }, error } = await supabase.auth.getUser();
        if (error || !user) {
            console.error('User authentication failed:', error);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].redirect(new URL('/login?error=Authentication required', request.url));
        }
        console.log('User authenticated, handling Google callback...', {
            userId: user.id
        });
        // Handle the callback and store tokens
        const success = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$calendar$2f$google$2d$calendar$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["handleGoogleCallback"])(code);
        if (!success) {
            console.error('Failed to handle Google callback and store tokens');
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].redirect(new URL('/dashboard?error=Failed to connect Google Calendar', request.url));
        }
        console.log('Successfully stored Google Calendar tokens, initiating sync...');
        // Verify tokens were stored
        const { data: connection, error: connectionError } = await supabase.from('calendar_connections').select('*').eq('user_id', user.id).eq('provider', 'google').single();
        if (connectionError || !connection) {
            console.error('Failed to verify calendar connection:', connectionError);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].redirect(new URL('/dashboard?error=Calendar connection verification failed', request.url));
        }
        console.log('Calendar connection verified, starting sync...');
        // Trigger immediate sync for 30 days ahead
        const syncSuccess = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$calendar$2f$background$2d$sync$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["syncUserCalendar"])(user.id);
        if (!syncSuccess) {
            console.error('Initial calendar sync failed');
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].redirect(new URL('/dashboard?success=Calendar connected but sync failed. Please try manual sync.', request.url));
        }
        // Verify events were synced
        const { count, error: eventCountError } = await supabase.from('calendar_events').select('*', {
            count: 'exact',
            head: true
        }).eq('user_id', user.id);
        console.log('Sync completed, event count:', {
            count,
            error: eventCountError
        });
        // Redirect back to dashboard with success message
        const successMessage = count ? `Calendar connected and synced successfully. Found ${count} events.` : 'Calendar connected successfully but no events found.';
        const redirectUrl = new URL('/dashboard', request.url);
        redirectUrl.searchParams.set('success', successMessage);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].redirect(redirectUrl);
    } catch (error) {
        console.error('Unexpected error in Google callback:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].redirect(new URL('/dashboard?error=An unexpected error occurred', request.url));
    }
}
}}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__18abe3d4._.js.map