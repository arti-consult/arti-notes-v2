module.exports = {

"[project]/.next-internal/server/app/api/auth/google/callback/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/punycode [external] (punycode, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[project]/src/utils/supabase/server.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createClient": (()=>createClient)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/ssr/dist/module/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/ssr/dist/module/createServerClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/headers.js [app-route] (ecmascript)");
;
;
async function createClient() {
    const cookieStore = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createServerClient"])(("TURBOPACK compile-time value", "https://wnxwqdupndeqijmamdkp.supabase.co"), ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndueHdxZHVwbmRlcWlqbWFtZGtwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzE4NDU4NTksImV4cCI6MjA0NzQyMTg1OX0.pJ2CF508xkmP2IPEoSkqJ45lMmNySVxHJYxeZ_Ge3Pw"), {
        cookies: {
            get (name) {
                return cookieStore.get(name)?.value;
            },
            set (name, value, options) {
                cookieStore.set({
                    name,
                    value,
                    ...options
                });
            },
            remove (name, options) {
                cookieStore.set({
                    name,
                    value: "",
                    ...options
                });
            }
        }
    });
}
}}),
"[externals]/child_process [external] (child_process, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[externals]/net [external] (net, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}}),
"[externals]/tls [external] (tls, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}}),
"[externals]/assert [external] (assert, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}}),
"[externals]/tty [external] (tty, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/querystring [external] (querystring, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/node:events [external] (node:events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:events", () => require("node:events"));

module.exports = mod;
}}),
"[externals]/node:process [external] (node:process, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:process", () => require("node:process"));

module.exports = mod;
}}),
"[externals]/node:util [external] (node:util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:util", () => require("node:util"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/http2 [external] (http2, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http2", () => require("http2"));

module.exports = mod;
}}),
"[externals]/process [external] (process, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}}),
"[project]/src/utils/supabase/client.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createClient": (()=>createClient)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/ssr/dist/module/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createBrowserClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/ssr/dist/module/createBrowserClient.js [app-route] (ecmascript)");
;
function createClient() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createBrowserClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createBrowserClient"])(("TURBOPACK compile-time value", "https://wnxwqdupndeqijmamdkp.supabase.co"), ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndueHdxZHVwbmRlcWlqbWFtZGtwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzE4NDU4NTksImV4cCI6MjA0NzQyMTg1OX0.pJ2CF508xkmP2IPEoSkqJ45lMmNySVxHJYxeZ_Ge3Pw"));
}
}}),
"[project]/src/utils/calendar/auth.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getGoogleAccessToken": (()=>getGoogleAccessToken)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$google$2d$auth$2d$library$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/google-auth-library/build/src/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/supabase/client.ts [app-route] (ecmascript)");
;
;
const GOOGLE_CLIENT_ID = ("TURBOPACK compile-time value", "438777486938-3qirleero26ui3t8e0svrojd89jrhpvs.apps.googleusercontent.com");
const GOOGLE_CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET;
const GOOGLE_REDIRECT_URI = process.env.NEXT_PUBLIC_GOOGLE_REDIRECT_URI;
async function getGoogleAccessToken(userId) {
    try {
        console.log("Getting Google access token for user:", userId);
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Get the user's calendar connection
        const { data: connection, error } = await supabase.from("calendar_connections").select("*").eq("user_id", userId).eq("provider", "google").single();
        if (error || !connection) {
            console.error("Failed to get calendar connection:", error);
            return null;
        }
        console.log("Found calendar connection:", {
            connectionId: connection.id,
            hasRefreshToken: !!connection.refresh_token,
            tokenExpiry: connection.token_expiry
        });
        // Create OAuth2 client
        const oauth2Client = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$google$2d$auth$2d$library$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["OAuth2Client"](GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, GOOGLE_REDIRECT_URI);
        // Set the refresh token
        oauth2Client.setCredentials({
            refresh_token: connection.refresh_token
        });
        // Get fresh access token using refresh token
        const response = await oauth2Client.getAccessToken();
        if (!response.token) {
            console.error("Failed to get access token");
            return null;
        }
        // Update the stored tokens
        const { error: updateError } = await supabase.from("calendar_connections").update({
            access_token: response.token,
            token_expiry: response.res?.data?.expiry_date ? new Date(response.res.data.expiry_date).toISOString() : null,
            updated_at: new Date().toISOString()
        }).eq("id", connection.id);
        if (updateError) {
            console.error("Failed to update tokens:", updateError);
        } else {
            console.log("Successfully updated tokens");
        }
        return response.token;
    } catch (error) {
        console.error("Error getting Google access token:", error);
        return null;
    }
}
}}),
"[project]/src/utils/calendar/google-calendar.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/utils/calendar/google-calendar.ts
__turbopack_context__.s({
    "createOAuth2Client": (()=>createOAuth2Client),
    "disconnectGoogleCalendar": (()=>disconnectGoogleCalendar),
    "fetchUpcomingGoogleEvents": (()=>fetchUpcomingGoogleEvents),
    "getGoogleAuthUrl": (()=>getGoogleAuthUrl),
    "handleGoogleCallback": (()=>handleGoogleCallback),
    "isGoogleCalendarConnected": (()=>isGoogleCalendarConnected),
    "refreshTokenIfNeeded": (()=>refreshTokenIfNeeded),
    "storeCalendarEvents": (()=>storeCalendarEvents),
    "syncGoogleCalendarEvents": (()=>syncGoogleCalendarEvents)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/googleapis/build/src/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/supabase/client.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/supabase/server.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$calendar$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/calendar/auth.ts [app-route] (ecmascript)");
;
;
;
;
// Google OAuth scopes needed
const SCOPES = [
    "https://www.googleapis.com/auth/calendar.readonly",
    "https://www.googleapis.com/auth/calendar.events.readonly"
];
// Google Calendar API credentials
const credentials = {
    client_id: ("TURBOPACK compile-time value", "438777486938-3qirleero26ui3t8e0svrojd89jrhpvs.apps.googleusercontent.com"),
    client_secret: process.env.GOOGLE_CLIENT_SECRET,
    redirect_uri: `${("TURBOPACK compile-time value", "http://localhost:3000")}/api/auth/google/callback`
};
// Debug log the credentials and environment
console.log("Environment check:", {
    NODE_ENV: ("TURBOPACK compile-time value", "development"),
    APP_URL: ("TURBOPACK compile-time value", "http://localhost:3000"),
    hasClientId: !!("TURBOPACK compile-time value", "438777486938-3qirleero26ui3t8e0svrojd89jrhpvs.apps.googleusercontent.com"),
    hasClientSecret: !!process.env.GOOGLE_CLIENT_SECRET
});
console.log("Google OAuth Configuration:", {
    redirectUri: credentials.redirect_uri,
    hasClientId: !!credentials.client_id,
    hasClientSecret: !!credentials.client_secret,
    scopes: SCOPES
});
function createOAuth2Client() {
    const client = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].auth.OAuth2(credentials.client_id, credentials.client_secret, credentials.redirect_uri);
    console.log("Created OAuth2 client with redirect URI:", credentials.redirect_uri);
    return client;
}
function getGoogleAuthUrl() {
    console.log("Generating Google OAuth URL...");
    const oauth2Client = createOAuth2Client();
    const url = oauth2Client.generateAuthUrl({
        access_type: "offline",
        scope: SCOPES,
        prompt: "consent",
        include_granted_scopes: true
    });
    console.log("Generated OAuth URL:", url);
    return url;
}
async function handleGoogleCallback(code) {
    try {
        const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        const oauth2Client = createOAuth2Client();
        // Exchange code for tokens
        const { tokens } = await oauth2Client.getToken(code);
        if (!tokens.access_token || !tokens.refresh_token) {
            console.error("Missing required tokens from Google");
            return false;
        }
        // Get current user
        const { data: { user }, error: userError } = await supabase.auth.getUser();
        if (userError || !user) {
            console.error("User not authenticated");
            return false;
        }
        console.log("Saving Google Calendar connection...");
        // First, check if a connection already exists
        const { data: existingConnection } = await supabase.from("calendar_connections").select("id").eq("user_id", user.id).eq("provider", "google").single();
        // Store tokens in Supabase calendar_connections table
        const connectionData = {
            user_id: user.id,
            provider: "google",
            access_token: tokens.access_token,
            refresh_token: tokens.refresh_token,
            token_expiry: tokens.expiry_date ? new Date(tokens.expiry_date).toISOString() : null,
            scope: SCOPES.join(" "),
            updated_at: new Date().toISOString()
        };
        let error;
        if (existingConnection) {
            // Update existing connection
            const { error: updateError } = await supabase.from("calendar_connections").update(connectionData).eq("id", existingConnection.id);
            error = updateError;
        } else {
            // Create new connection
            const { error: insertError } = await supabase.from("calendar_connections").insert({
                ...connectionData,
                created_at: new Date().toISOString()
            });
            error = insertError;
        }
        if (error) {
            console.error("Error storing tokens:", error);
            return false;
        }
        console.log("Successfully stored Google Calendar connection");
        return true;
    } catch (error) {
        console.error("Error handling Google callback:", error);
        return false;
    }
}
async function refreshTokenIfNeeded(userId) {
    try {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Get stored tokens from calendar_connections
        const { data, error } = await supabase.from("calendar_connections").select("*").eq("user_id", userId).eq("provider", "google").single();
        if (error || !data) {
            console.error("No Google Calendar connection found");
            return false;
        }
        // Check if token is expired
        const tokenExpiry = new Date(data.token_expiry);
        const now = new Date();
        if (tokenExpiry <= now && data.refresh_token) {
            console.log("Refreshing expired token...");
            // Token is expired, refresh it
            const oauth2Client = createOAuth2Client();
            oauth2Client.setCredentials({
                refresh_token: data.refresh_token
            });
            const response = await oauth2Client.getAccessToken();
            const token = response.token;
            const expiryDate = oauth2Client.credentials.expiry_date;
            // Update tokens in database
            const { error: updateError } = await supabase.from("calendar_connections").update({
                access_token: token,
                token_expiry: expiryDate ? new Date(expiryDate).toISOString() : null,
                updated_at: new Date().toISOString()
            }).eq("user_id", userId).eq("provider", "google");
            if (updateError) {
                console.error("Error updating tokens:", updateError);
                return false;
            }
        }
        return true;
    } catch (error) {
        console.error("Error refreshing token:", error);
        return false;
    }
}
async function fetchUpcomingGoogleEvents(userId, daysAhead = 30) {
    try {
        console.log(`Fetching Google Calendar events for user ${userId}...`);
        // Get access token
        const accessToken = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$calendar$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getGoogleAccessToken"])(userId);
        if (!accessToken) {
            console.error("Failed to get access token");
            return [];
        }
        console.log("âœ“ Successfully got access token");
        // Setup OAuth client with token
        console.log("Setting up OAuth client...");
        const oauth2Client = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].auth.OAuth2(credentials.client_id, credentials.client_secret, credentials.redirect_uri);
        oauth2Client.setCredentials({
            access_token: accessToken
        });
        const calendar = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].calendar({
            version: "v3",
            auth: oauth2Client
        });
        // Calculate time range
        const now = new Date();
        const timeMin = now.toISOString();
        const future = new Date();
        future.setDate(future.getDate() + daysAhead);
        const timeMax = future.toISOString();
        console.log(`Fetching events from ${timeMin} to ${timeMax}`);
        // Fetch calendar list first
        console.log("Fetching calendar list...");
        const { data: { items: calendarList } } = await calendar.calendarList.list();
        if (!calendarList || calendarList.length === 0) {
            console.log("No calendars found");
            return [];
        }
        console.log(`Found ${calendarList.length} calendars:`, calendarList.map((cal)=>({
                id: cal.id,
                summary: cal.summary,
                primary: cal.primary
            })));
        // Fetch events from each calendar
        const allEvents = [];
        for (const cal of calendarList){
            if (!cal.id) continue;
            console.log(`\nFetching events for calendar: ${cal.summary} (${cal.id})`);
            const response = await calendar.events.list({
                calendarId: cal.id,
                timeMin,
                timeMax,
                singleEvents: true,
                orderBy: "startTime"
            });
            const events = response.data.items || [];
            if (events.length === 0) {
                console.log(`No events found for calendar ${cal.summary}`);
                continue;
            }
            console.log(`Found ${events.length} events for calendar ${cal.summary}`);
            // Log first 5 events details for debugging
            events.slice(0, 5).forEach((event, index)=>{
                console.log(`\nEvent ${index + 1}:`, {
                    id: event.id,
                    summary: event.summary,
                    start: event.start?.dateTime || event.start?.date,
                    end: event.end?.dateTime || event.end?.date,
                    attendees: event.attendees?.length || 0,
                    hasHangoutLink: !!event.hangoutLink,
                    hasConferenceData: !!event.conferenceData,
                    organizer: event.organizer?.email,
                    status: event.status
                });
            });
            for (const event of events){
                if (!event.id || !event.summary) continue;
                // Get meeting link
                let meetingLink = null;
                if (event.hangoutLink) {
                    meetingLink = event.hangoutLink;
                } else if (event.conferenceData?.entryPoints) {
                    const videoEntry = event.conferenceData.entryPoints.find((entry)=>entry.entryPointType === "video");
                    if (videoEntry?.uri) {
                        meetingLink = videoEntry.uri;
                    }
                }
                // Get attendees
                const attendees = event.attendees?.map((attendee)=>({
                        email: attendee.email || "",
                        name: attendee.displayName || undefined
                    })) || [];
                // Check if user is organizer
                const isOrganizer = event.organizer?.email === event.attendees?.find((attendee)=>attendee.self)?.email;
                // Format dates correctly
                const startTime = event.start?.dateTime || (event.start?.date ? `${event.start.date}T00:00:00` : null);
                const endTime = event.end?.dateTime || (event.end?.date ? `${event.end.date}T23:59:59` : null);
                if (!startTime || !endTime) continue;
                allEvents.push({
                    id: event.id,
                    calendar_id: cal.id,
                    title: event.summary,
                    description: event.description || null,
                    start_time: startTime,
                    end_time: endTime,
                    location: event.location || null,
                    meeting_link: meetingLink,
                    attendees,
                    is_organizer: isOrganizer,
                    status: event.status || "confirmed",
                    html_link: event.htmlLink || "",
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString()
                });
            }
        }
        console.log(`\nTotal events found across all calendars: ${allEvents.length}`);
        console.log("First 3 processed events:", allEvents.slice(0, 3).map((event)=>({
                title: event.title,
                start: event.start_time,
                end: event.end_time,
                attendees: event.attendees.length,
                has_meeting: !!event.meeting_link
            })));
        return allEvents.sort((a, b)=>new Date(a.start_time).getTime() - new Date(b.start_time).getTime());
    } catch (error) {
        console.error("Error fetching Google Calendar events:", error);
        return [];
    }
}
async function storeCalendarEvents(userId, events) {
    try {
        console.log(`Storing ${events.length} calendar events in Supabase...`);
        if (events.length === 0) {
            console.log("No events to store");
            return true;
        }
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Format events for insertion
        const formattedEvents = events.map((event)=>({
                user_id: userId,
                provider: "google",
                external_event_id: event.id,
                calendar_id: event.calendar_id,
                title: event.title,
                description: event.description,
                start_time: event.start_time,
                end_time: event.end_time,
                location: event.location,
                meeting_link: event.meeting_link,
                attendees: event.attendees,
                is_organizer: event.is_organizer,
                status: event.status,
                html_link: event.html_link,
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
            }));
        console.log("Upserting events to Supabase...");
        // Upsert events to handle both new and updated events
        const { error } = await supabase.from("calendar_events").upsert(formattedEvents, {
            onConflict: "user_id,provider,external_event_id"
        });
        if (error) {
            console.error("Error storing calendar events:", error);
            return false;
        }
        console.log("Events stored successfully");
        // Update last sync timestamp
        console.log("Updating last sync timestamp...");
        const { error: profileError } = await supabase.from("profiles").update({
            last_calendar_sync: new Date().toISOString()
        }).eq("id", userId);
        if (profileError) {
            console.error("Error updating last sync timestamp:", profileError);
        }
        return true;
    } catch (error) {
        console.error("Error storing calendar events:", error);
        return false;
    }
}
async function syncGoogleCalendarEvents(userId, daysAhead = 30) {
    try {
        console.log(`Starting calendar sync for user ${userId}...`);
        // Get access token
        const accessToken = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$calendar$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getGoogleAccessToken"])(userId);
        if (!accessToken) {
            console.error("Failed to get access token");
            return false;
        }
        console.log("Successfully got access token");
        // Fetch events from Google Calendar
        const events = await fetchUpcomingGoogleEvents(userId, daysAhead);
        if (events.length === 0) {
            console.log("No events to sync");
            return true;
        }
        console.log(`Found ${events.length} events to sync`);
        // Store events in Supabase
        const success = await storeCalendarEvents(userId, events);
        if (!success) {
            console.error("Failed to store calendar events");
            return false;
        }
        console.log("Successfully synced calendar events");
        return true;
    } catch (error) {
        console.error("Error syncing Google Calendar events:", error);
        return false;
    }
}
async function isGoogleCalendarConnected(userId) {
    try {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        const { data, error } = await supabase.from("calendar_connections").select("id").eq("user_id", userId).eq("provider", "google").single();
        return !error && !!data;
    } catch (error) {
        console.error("Error checking Google Calendar connection:", error);
        return false;
    }
}
async function disconnectGoogleCalendar(userId) {
    try {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Delete connection record
        const { error } = await supabase.from("calendar_connections").delete().eq("user_id", userId).eq("provider", "google");
        if (error) {
            console.error("Error disconnecting Google Calendar:", error);
            return false;
        }
        return true;
    } catch (error) {
        console.error("Error disconnecting Google Calendar:", error);
        return false;
    }
}
}}),
"[project]/src/services/calendarEventService.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/utils/calendar/calendar-events-service.ts
__turbopack_context__.s({
    "createMeetingsFromCalendarEvents": (()=>createMeetingsFromCalendarEvents),
    "determineMeetingType": (()=>determineMeetingType),
    "getSyncedCalendarEvents": (()=>getSyncedCalendarEvents),
    "getUpcomingCalendarEventsWithMeetingLinks": (()=>getUpcomingCalendarEventsWithMeetingLinks),
    "updateMeetingsFromCalendarEvents": (()=>updateMeetingsFromCalendarEvents)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/supabase/client.ts [app-route] (ecmascript)");
;
async function getUpcomingCalendarEventsWithMeetingLinks(daysAhead = 7) {
    try {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Get upcoming events with meeting links
        const { data, error } = await supabase.from('calendar_events').select('*').not('meeting_link', 'is', null).gte('start_time', new Date().toISOString()).lte('start_time', new Date(Date.now() + daysAhead * 24 * 60 * 60 * 1000).toISOString()).order('start_time', {
            ascending: true
        });
        if (error) {
            console.error('Error fetching upcoming events:', error);
            return [];
        }
        return data || [];
    } catch (error) {
        console.error('Error fetching upcoming events:', error);
        return [];
    }
}
function determineMeetingType(meetingLink) {
    const lowerCaseLink = meetingLink.toLowerCase();
    if (lowerCaseLink.includes('meet.google.com')) {
        return 'google-meets';
    } else if (lowerCaseLink.includes('teams.microsoft.com')) {
        return 'microsoft-teams';
    } else {
        return 'live';
    }
}
async function createMeetingsFromCalendarEvents() {
    try {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Get upcoming events with meeting links that haven't been synced
        const { data: events, error } = await supabase.from('calendar_events').select('*').not('meeting_link', 'is', null).eq('synced_to_meeting', false).gte('start_time', new Date().toISOString()).order('start_time', {
            ascending: true
        });
        if (error) {
            console.error('Error fetching calendar events:', error);
            return 0;
        }
        if (!events || events.length === 0) {
            return 0;
        }
        let syncedCount = 0;
        // Process each event
        for (const event of events){
            if (!event.meeting_link) continue;
            // Determine meeting type
            const meetingType = determineMeetingType(event.meeting_link);
            // Create meeting
            const { data: meeting, error: meetingError } = await supabase.from('meetings').insert({
                title: event.title,
                description: event.description,
                user_id: event.user_id,
                meeting_type: meetingType,
                start_time: event.start_time,
                end_time: event.end_time,
                calendar_event_id: event.id,
                meeting_url: event.meeting_link,
                attendees: event.attendees,
                location: event.location,
                status: 'scheduled',
                transcription_status: 'pending',
                summary_status: 'pending'
            }).select('id').single();
            if (meetingError) {
                console.error('Error creating meeting from calendar event:', meetingError);
                continue;
            }
            // Update calendar event with meeting ID
            const { error: updateError } = await supabase.from('calendar_events').update({
                synced_to_meeting: true,
                meeting_id: meeting.id
            }).eq('id', event.id);
            if (updateError) {
                console.error('Error updating calendar event:', updateError);
                continue;
            }
            syncedCount++;
        }
        return syncedCount;
    } catch (error) {
        console.error('Error creating meetings from calendar events:', error);
        return 0;
    }
}
async function getSyncedCalendarEvents() {
    try {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Get events that have been synced to meetings
        const { data, error } = await supabase.from('calendar_events').select(`
        *,
        meetings:meeting_id (
          id,
          title,
          start_time,
          end_time,
          meeting_type,
          transcription_status,
          summary_status
        )
      `).eq('synced_to_meeting', true).order('start_time', {
            ascending: false
        });
        if (error) {
            console.error('Error fetching synced events:', error);
            return [];
        }
        return data || [];
    } catch (error) {
        console.error('Error fetching synced events:', error);
        return [];
    }
}
async function updateMeetingsFromCalendarEvents() {
    try {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Get synced events
        const { data: events, error } = await supabase.from('calendar_events').select(`
        *,
        meetings:meeting_id (
          id,
          title,
          start_time,
          end_time
        )
      `).eq('synced_to_meeting', true).not('meeting_id', 'is', null);
        if (error) {
            console.error('Error fetching synced events:', error);
            return 0;
        }
        if (!events || events.length === 0) {
            return 0;
        }
        let updatedCount = 0;
        // Process each event
        for (const event of events){
            if (!event.meeting_id || !event.meetings) continue;
            const meeting = event.meetings;
            // Check if meeting needs updating
            if (meeting.title !== event.title || meeting.start_time !== event.start_time || meeting.end_time !== event.end_time) {
                // Update meeting
                const { error: updateError } = await supabase.from('meetings').update({
                    title: event.title,
                    start_time: event.start_time,
                    end_time: event.end_time,
                    updated_at: new Date().toISOString()
                }).eq('id', event.meeting_id);
                if (updateError) {
                    console.error('Error updating meeting:', updateError);
                    continue;
                }
                updatedCount++;
            }
        }
        return updatedCount;
    } catch (error) {
        console.error('Error updating meetings from calendar events:', error);
        return 0;
    }
}
}}),
"[project]/src/utils/calendar/background-sync.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/utils/calendar/background-sync.ts
__turbopack_context__.s({
    "syncAllUserCalendars": (()=>syncAllUserCalendars),
    "syncUserCalendar": (()=>syncUserCalendar)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/supabase/server.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$calendar$2f$google$2d$calendar$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/calendar/google-calendar.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$calendarEventService$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/services/calendarEventService.ts [app-route] (ecmascript)");
;
;
;
async function syncUserCalendar(userId) {
    try {
        console.log(`Starting calendar sync for user ${userId}...`);
        const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // 1. Verify calendar connection
        const { data: connection, error: connectionError } = await supabase.from("calendar_connections").select("*").eq("user_id", userId).eq("provider", "google").single();
        if (connectionError || !connection) {
            console.error("No valid calendar connection found:", connectionError);
            return false;
        }
        console.log("Found valid calendar connection:", {
            connectionId: connection.id,
            provider: connection.provider,
            lastSync: connection.last_sync
        });
        // 2. Sync Google Calendar events
        console.log("Starting Google Calendar sync...");
        const calendarSyncSuccess = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$calendar$2f$google$2d$calendar$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["syncGoogleCalendarEvents"])(userId);
        if (!calendarSyncSuccess) {
            console.error("Failed to sync Google Calendar events");
            return false;
        }
        console.log("Google Calendar events synced successfully");
        // 3. Create meetings from calendar events with meeting links
        console.log("Creating meetings from calendar events...");
        const createdMeetings = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$calendarEventService$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createMeetingsFromCalendarEvents"])();
        console.log(`Created ${createdMeetings} meetings from calendar events`);
        // 4. Update existing meetings if calendar events have changed
        console.log("Updating existing meetings...");
        const updatedMeetings = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$calendarEventService$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["updateMeetingsFromCalendarEvents"])();
        console.log(`Updated ${updatedMeetings} existing meetings`);
        // 5. Update last sync timestamp
        console.log("Updating last sync timestamp...");
        const { error: updateError } = await supabase.from("profiles").update({
            last_calendar_sync: new Date().toISOString()
        }).eq("id", userId);
        if (updateError) {
            console.error("Failed to update last sync timestamp:", updateError);
        }
        // 6. Get final event count
        console.log("Getting final event count...");
        const { data: events, count, error: countError } = await supabase.from("calendar_events").select("*", {
            count: "exact"
        }).eq("user_id", userId);
        console.log("Calendar sync completed successfully", {
            userId,
            totalEvents: count,
            createdMeetings,
            updatedMeetings,
            events: events?.map((e)=>({
                    id: e.id,
                    title: e.title,
                    start_time: e.start_time
                })),
            error: countError
        });
        return true;
    } catch (error) {
        console.error("Error in complete user calendar sync:", error);
        return false;
    }
}
async function syncAllUserCalendars() {
    try {
        const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Get all users with their sync frequency
        const { data: profiles, error } = await supabase.from("profiles").select(`
        id,
        calendar_sync_frequency,
        last_calendar_sync
      `).not("calendar_sync_frequency", "eq", "manual");
        if (error) {
            console.error("Error fetching user profiles:", error);
            return {
                success: false,
                syncedUsers: 0
            };
        }
        if (!profiles || profiles.length === 0) {
            return {
                success: true,
                syncedUsers: 0
            };
        }
        let syncedUsers = 0;
        const now = new Date();
        // Process each user based on their sync frequency
        for (const profile of profiles){
            // Skip if no sync frequency
            if (!profile.calendar_sync_frequency) continue;
            const lastSync = profile.last_calendar_sync ? new Date(profile.last_calendar_sync) : null;
            let shouldSync = false;
            // Determine if we should sync based on frequency
            switch(profile.calendar_sync_frequency){
                case "realtime":
                    shouldSync = true;
                    break;
                case "hourly":
                    shouldSync = !lastSync || now.getTime() - lastSync.getTime() >= 60 * 60 * 1000;
                    break;
                case "daily":
                    shouldSync = !lastSync || now.getTime() - lastSync.getTime() >= 24 * 60 * 60 * 1000;
                    break;
                case "weekly":
                    shouldSync = !lastSync || now.getTime() - lastSync.getTime() >= 7 * 24 * 60 * 60 * 1000;
                    break;
                default:
                    shouldSync = false;
            }
            if (shouldSync) {
                // Use the new syncUserCalendar function for consistency
                const success = await syncUserCalendar(profile.id);
                if (success) {
                    syncedUsers++;
                }
            }
        }
        return {
            success: true,
            syncedUsers
        };
    } catch (error) {
        console.error("Error syncing user calendars:", error);
        return {
            success: false,
            syncedUsers: 0
        };
    }
}
}}),
"[project]/src/app/api/auth/google/callback/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GET": (()=>GET)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/supabase/server.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$calendar$2f$google$2d$calendar$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/calendar/google-calendar.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$calendar$2f$background$2d$sync$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/calendar/background-sync.ts [app-route] (ecmascript)");
;
;
;
;
async function GET(request) {
    try {
        console.log("Starting Google OAuth callback handler...");
        const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Get the authorization code from the URL
        const url = new URL(request.url);
        const code = url.searchParams.get("code");
        if (!code) {
            console.error("No authorization code received");
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].redirect(new URL("/dashboard?error=No authorization code received", request.url));
        }
        console.log("Received authorization code, verifying user...");
        // Verify user is authenticated
        const { data: { user }, error: userError } = await supabase.auth.getUser();
        if (userError || !user) {
            console.error("User not authenticated:", userError);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].redirect(new URL("/dashboard?error=User not authenticated", request.url));
        }
        console.log("User authenticated, handling Google callback...", {
            userId: user.id
        });
        // Handle the Google callback and store tokens
        const success = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$calendar$2f$google$2d$calendar$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["handleGoogleCallback"])(code);
        if (!success) {
            console.error("Failed to handle Google callback");
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].redirect(new URL("/dashboard?error=Failed to connect Google Calendar", request.url));
        }
        console.log("Successfully stored Google Calendar tokens, initiating sync...");
        // Verify calendar connection was created
        const { data: connection, error: connectionError } = await supabase.from("calendar_connections").select("*").eq("user_id", user.id).eq("provider", "google").single();
        if (connectionError || !connection) {
            console.error("Failed to verify calendar connection:", connectionError);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].redirect(new URL("/dashboard?error=Calendar connection verification failed", request.url));
        }
        console.log("Calendar connection verified, starting sync...");
        // Trigger immediate sync for 30 days ahead
        const syncSuccess = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$calendar$2f$background$2d$sync$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["syncUserCalendar"])(user.id);
        if (!syncSuccess) {
            console.error("Initial calendar sync failed");
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].redirect(new URL("/dashboard?success=Calendar connected but sync failed. Please try manual sync.", request.url));
        }
        // Verify events were synced
        const { count, error: eventCountError } = await supabase.from("calendar_events").select("*", {
            count: "exact",
            head: true
        }).eq("user_id", user.id);
        console.log("Sync completed, event count:", {
            count,
            error: eventCountError
        });
        // Redirect back to dashboard with success message
        const successMessage = count ? `Calendar connected and synced successfully. Found ${count} events.` : "Calendar connected successfully but no events found.";
        const redirectUrl = new URL("/dashboard", request.url);
        redirectUrl.searchParams.set("success", successMessage);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].redirect(redirectUrl);
    } catch (error) {
        console.error("Unexpected error in Google callback:", error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].redirect(new URL("/dashboard?error=An unexpected error occurred", request.url));
    }
}
}}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__4aad37a8._.js.map