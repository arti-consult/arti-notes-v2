{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/middleware.ts"],"sourcesContent":["// src/middleware.ts\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { createServerClient } from \"@supabase/ssr\";\n\n// Define protection rules for routes\nconst protectedRoutes = [\n  {\n    path: \"/dashboard\",\n    requireAuth: true,\n    minTier: \"free\", // \"free\", \"basic\", \"premium\", or \"admin\"\n  },\n  {\n    path: \"/admin\",\n    requireAuth: true,\n    minTier: \"admin\",\n  },\n  {\n    path: \"/settings\",\n    requireAuth: true,\n    minTier: \"free\",\n  },\n  {\n    path: \"/meetings\",\n    requireAuth: true,\n    minTier: \"free\",\n  },\n  {\n    path: \"/api/recordings\",\n    requireAuth: true,\n    minTier: \"free\",\n  },\n];\n\nexport async function middleware(request: NextRequest) {\n  let response = NextResponse.next({\n    request: {\n      headers: request.headers,\n    },\n  });\n\n  const supabase = createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return request.cookies.getAll();\n        },\n        setAll(cookiesToSet) {\n          cookiesToSet.forEach(({ name, value }) =>\n            request.cookies.set(name, value)\n          );\n          response = NextResponse.next({\n            request: {\n              headers: request.headers,\n            },\n          });\n          cookiesToSet.forEach(({ name, value, options }) =>\n            response.cookies.set(name, value, options)\n          );\n        },\n      },\n    }\n  );\n\n  // Use getUser for secure authentication\n  const {\n    data: { user },\n    error: userError,\n  } = await supabase.auth.getUser();\n  const pathname = request.nextUrl.pathname;\n\n  // If not logged in, redirect to login\n  if (!user) {\n    if (pathname !== \"/login\") {\n      return NextResponse.redirect(new URL(\"/login\", request.url));\n    }\n    return response;\n  }\n\n  // 1. Check for active or trialing subscription\n  const { data: subscription } = await supabase\n    .from(\"subscriptions\")\n    .select(\"status\")\n    .eq(\"user_id\", user.id)\n    .in(\"status\", [\"active\", \"trialing\"])\n    .single();\n\n  console.log(\"User ID:\", user.id);\n  console.log(\"Subscription found:\", subscription);\n\n  if (!subscription && pathname !== \"/subscribe\" && pathname !== \"/\") {\n    // Allow access to home page without subscription\n    return NextResponse.redirect(new URL(\"/subscribe\", request.url));\n  }\n\n  // 2. Check onboarding\n  const { data: onboarding } = await supabase\n    .from(\"user_onboarding\")\n    .select(\"completed_at\")\n    .eq(\"user_id\", user.id)\n    .not(\"completed_at\", \"is\", null)\n    .single();\n\n  if (subscription && !onboarding && pathname !== \"/onboarding\") {\n    // Redirect to onboarding if not completed\n    return NextResponse.redirect(new URL(\"/onboarding\", request.url));\n  }\n\n  // 3. If both are true, allow access to dashboard\n  if (pathname === \"/dashboard\" && (!subscription || !onboarding)) {\n    // If trying to access dashboard without both, redirect accordingly\n    if (!subscription) {\n      return NextResponse.redirect(new URL(\"/subscribe\", request.url));\n    }\n    if (!onboarding) {\n      return NextResponse.redirect(new URL(\"/onboarding\", request.url));\n    }\n  }\n\n  // Check if the path is protected\n  const protectedRoute = protectedRoutes.find((route) =>\n    pathname.startsWith(route.path)\n  );\n\n  // If route is protected and user is not authenticated, redirect to login\n  if (protectedRoute?.requireAuth && !user) {\n    const redirectUrl = new URL(\"/login\", request.url);\n    redirectUrl.searchParams.set(\"redirect\", pathname);\n    return NextResponse.redirect(redirectUrl);\n  }\n\n  // If authenticated and route requires a minimum tier\n  if (user && protectedRoute?.minTier) {\n    // Skip tier check for admin paths if the path itself requires admin access\n    if (pathname.startsWith(\"/admin\") && protectedRoute.minTier === \"admin\") {\n      // Check if user is admin\n      const { data } = await supabase\n        .from(\"user_roles\")\n        .select(\n          `\n          roles!inner (\n            name\n          )\n        `\n        )\n        .eq(\"user_id\", user.id)\n        .eq(\"roles.name\", \"admin\");\n\n      // If not admin, redirect to dashboard\n      if (!data || data.length === 0) {\n        return NextResponse.redirect(new URL(\"/dashboard\", request.url));\n      }\n    } else if (protectedRoute.minTier !== \"free\") {\n      // For non-admin paths that require a minimum tier other than free\n      const getTierLevel = (tier: string): number => {\n        const levels = { free: 0, basic: 1, premium: 2, admin: 3 };\n        return levels[tier as keyof typeof levels] || 0;\n      };\n\n      const { data: userRoles } = await supabase\n        .from(\"user_roles\")\n        .select(\n          `\n          roles!inner (\n            name\n          )\n        `\n        )\n        .eq(\"user_id\", user.id);\n\n      const minTierLevel = getTierLevel(protectedRoute.minTier);\n      const userTiers =\n        userRoles?.map((ur) => getTierLevel((ur.roles as any).name)) || [];\n      const maxUserTier = Math.max(...userTiers, 0);\n\n      if (maxUserTier < minTierLevel) {\n        return NextResponse.redirect(\n          new URL(\"/pricing?upgrade=true\", request.url)\n        );\n      }\n    }\n  }\n\n  // Only check subscription for protected routes\n  if (protectedRoute?.requireAuth) {\n    const { data: subscription } = await supabase\n      .from(\"subscriptions\")\n      .select(\"status\")\n      .eq(\"user_id\", user.id)\n      .in(\"status\", [\"active\", \"trialing\"])\n      .single();\n\n    if (!subscription && pathname !== \"/subscribe\") {\n      return NextResponse.redirect(new URL(\"/subscribe\", request.url));\n    }\n  }\n\n  return response;\n}\n\nexport const config = {\n  matcher: [\n    /*\n     * Match all request paths except for:\n     * - _next/static (static files)\n     * - _next/image (image optimization files)\n     * - favicon.ico (favicon file)\n     * - public files (assets)\n     * - api/webhooks (webhook endpoints)\n     * - auth pages (to prevent redirect loops)\n     */\n    \"/((?!_next/static|_next/image|favicon.ico|api/webhooks|login|register|onboarding|pricing|.*\\\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)\",\n  ],\n};\n"],"names":[],"mappings":"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"}}]
}